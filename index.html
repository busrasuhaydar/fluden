<!DOCTYPE html>
<html lang="en">
<head>
    <title>busfluid</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100vw;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
        }

        canvas {
            display: block;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            outline: 0;
        }

        /* HÄ°Ã‡BÄ°R YAZI YOK */
        div, span, p, h1, h2, h3, h4, h5, h6,
        [class*="fps"], [class*="cpu"], [class*="gpu"],
        [class*="cables"], [id*="stats"] {
            display: none !important;
            visibility: hidden !important;
        }

        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

    </style>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1">
</head>
<body>
    <canvas id="glcanvas" width="100vw" height="100vh" tabindex="1"></canvas>

    <script type="text/javascript" src="js/patch.js" async></script>

    <script type="text/javascript">

        function showError(initiator,...args) {
            // Silent
        }

        function patchInitialized(patch) {
            forceFullscreen();
            hideAllText();
            setInterval(hideAllText, 200);
            console.log('âœ… Fluid hazÄ±r!');
        }

        function patchFinishedLoading(patch) {
            forceFullscreen();
        }

        function forceFullscreen() {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
            `;
            
            document.body.style.cssText = `
                width: 100vw !important;
                height: 100vh !important;
                overflow: hidden !important;
                position: fixed !important;
            `;
        }

        function hideAllText() {
            document.querySelectorAll('div, span, p, h1, h2, h3, h4, h5, h6').forEach(el => {
                if (el.tagName.toLowerCase() !== 'canvas') {
                    el.style.display = 'none';
                }
            });
        }

        window.addEventListener('resize', forceFullscreen);
        window.addEventListener('load', forceFullscreen);

        // ðŸŽ¹ PÄ°YANO MESAJ SÄ°STEMÄ°
        window.addEventListener('message', (event) => {
            if (event.data.type === 'pianoKeyPress') {
                const colors = event.data.colors || [];
                const key = event.data.key;
                
                if (colors.length === 0) return;
                
                // RANDOM POZÄ°SYON - Her tuÅŸ farklÄ± yerde
                const x = 50 + Math.random() * (window.innerWidth - 100);
                const y = 50 + Math.random() * (window.innerHeight - 100);
                
                console.log('ðŸŽ¹', key.toUpperCase(), 'â†’', colors.length, 'renk');
                
                // Rengi set et - DAHA BELÄ°RGÄ°N
                const color = colors[0];
                setPianoColor(color);
                
                // Mouse simÃ¼lasyonu
                createPianoSpiral(x, y);
            }
        });

        function setPianoColor(color) {
            if (typeof CABLES === 'undefined' || !CABLES.patch) return;
            
            // RENK BELÄ°RGÄ°NLEÅžTÄ°RME - ULTRA AGGRESSIVE
            let r = color.r;
            let g = color.g;
            let b = color.b;
            
            // 1. Koyu renkleri aydÄ±nlat
            const brightness = (r + g + b) / 3;
            if (brightness < 120) {
                const factor = 120 / Math.max(brightness, 1);
                r = Math.min(255, r * factor);
                g = Math.min(255, g * factor);
                b = Math.min(255, b * factor);
            }
            
            // 2. Saturation boost - MAXIMUM
            const max = Math.max(r, g, b);
            const avg = (r + g + b) / 3;
            
            if (max > 0) {
                const boost = 1.8; // Maksimum boost
                r = Math.min(255, Math.max(0, avg + (r - avg) * boost));
                g = Math.min(255, Math.max(0, avg + (g - avg) * boost));
                b = Math.min(255, Math.max(0, avg + (b - avg) * boost));
            }
            
            // 3. Minimum parlaklÄ±k garantisi
            const finalBrightness = (r + g + b) / 3;
            if (finalBrightness < 100) {
                const addBrightness = (100 - finalBrightness) / 3;
                r = Math.min(255, r + addBrightness);
                g = Math.min(255, g + addBrightness);
                b = Math.min(255, b + addBrightness);
            }
            
            try {
                CABLES.patch.setVariable('SplatColor', [r/255, g/255, b/255]);
                console.log('âœ… Renk:', Math.round(r), Math.round(g), Math.round(b));
            } catch(e) {}
        }

        function createPianoSpiral(startX, startY) {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            // Mouse down
            canvas.dispatchEvent(new MouseEvent('mousedown', {
                clientX: startX,
                clientY: startY,
                button: 0,
                buttons: 1,
                bubbles: true
            }));
            
            let angle = 0;
            let radius = 0;
            let step = 0;
            const maxSteps = 35;
            
            const interval = setInterval(() => {
                angle += 0.6;
                radius += 3.5;
                
                const x = startX + Math.cos(angle) * radius;
                const y = startY + Math.sin(angle) * radius;
                
                // Mouse move
                canvas.dispatchEvent(new MouseEvent('mousemove', {
                    clientX: x,
                    clientY: y,
                    button: 0,
                    buttons: 1,
                    bubbles: true
                }));
                
                step++;
                if (step >= maxSteps) {
                    clearInterval(interval);
                    
                    // Mouse up
                    canvas.dispatchEvent(new MouseEvent('mouseup', {
                        clientX: x,
                        clientY: y,
                        button: 0,
                        buttons: 0,
                        bubbles: true
                    }));
                }
            }, 16);
        }

        document.addEventListener("CABLES.jsLoaded", function (event) {
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "js/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true }
            });
        });

        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
    </script>
</body>
</html>
