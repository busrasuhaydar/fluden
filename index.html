<!DOCTYPE html>
<html lang="en">
<head>
    <title>Piano Fluid - Living Art</title>
    <style>
        * {
            margin: 0 !important;
            padding: 0 !important;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            box-sizing: border-box !important;
        }

        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent !important;
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            position: relative;
        }

        #glcanvas {
            display: block !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            outline: 0 !important;
            transform: none !important;
            background: transparent !important;
        }

        /* FPS/CPU yazÄ±larÄ±nÄ± gizle */
        div[style*="position: absolute"],
        div[style*="fixed"],
        .cables-stats,
        .stats-panel {
            display: none !important;
            visibility: hidden !important;
        }

    </style>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
</head>
<body>
    <canvas id="glcanvas" tabindex="1"></canvas>

    <script type="text/javascript" src="js/patch.js" async></script>

    <script type="text/javascript">

        function showError(initiator,...args) {
            // Silent
        }

        let parentWidth = window.innerWidth;
        let parentHeight = window.innerHeight;

        if (window.parent !== window) {
            try {
                parentWidth = window.parent.innerWidth;
                parentHeight = window.parent.innerHeight;
            } catch(e) {}
        }

        function forceFullScreenCanvas() {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth || document.documentElement.clientWidth;
            const height = parentHeight || window.innerHeight || document.documentElement.clientHeight;
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            
            console.log('ðŸ”§ Canvas boyutu:', width, 'x', height);
        }

        function patchInitialized(patch) {
            console.log('âœ… Fluid hazÄ±r!');
            hideStatsPanels();
            forceFullScreenCanvas();
            
            setTimeout(forceFullScreenCanvas, 100);
            setTimeout(forceFullScreenCanvas, 500);
            setTimeout(forceFullScreenCanvas, 1000);
            setTimeout(forceFullScreenCanvas, 2000);
        }

        function patchFinishedLoading(patch) {
            console.log('ðŸŽ¨ YÃ¼kleme tamamlandÄ±!');
            hideStatsPanels();
            forceFullScreenCanvas();
        }

        function hideStatsPanels() {
            setTimeout(() => {
                const statsDivs = document.querySelectorAll('div');
                statsDivs.forEach(div => {
                    const style = div.getAttribute('style');
                    if (style && (style.includes('position: absolute') || style.includes('position: fixed'))) {
                        div.style.display = 'none';
                        div.style.visibility = 'hidden';
                    }
                });
            }, 100);
        }

        // ðŸŽ¨ EN CANLI ANA RENKLERÄ° SEÃ‡
        function selectBestColors(colors) {
            if (!colors || colors.length === 0) {
                return [
                    {r: 255, g: 100, b: 200},
                    {r: 100, g: 200, b: 255},
                    {r: 255, g: 200, b: 100}
                ];
            }

            // Sadece en canlÄ±, doygun renkleri al
            const vibrantColors = colors.filter(c => {
                const brightness = (c.r + c.g + c.b) / 3;
                const saturation = Math.max(c.r, c.g, c.b) - Math.min(c.r, c.g, c.b);
                
                // Daha agresif filtreleme - SADECE CANLI RENKLER
                return brightness > 50 && brightness < 220 && saturation > 40;
            });

            const workingColors = vibrantColors.length > 0 ? vibrantColors : colors;

            // DoygunluÄŸa gÃ¶re sÄ±rala - EN CANLILAR Ã–NCELÄ°KLÄ°
            const sortedByVibrance = [...workingColors].sort((a, b) => {
                const satA = Math.max(a.r, a.g, a.b) - Math.min(a.r, a.g, a.b);
                const satB = Math.max(b.r, b.g, b.b) - Math.min(b.r, b.g, b.b);
                return satB - satA;
            });

            // Ä°lk 15 en canlÄ± rengi al
            return sortedByVibrance.slice(0, 15);
        }

        // ðŸŒ€ Ã‡OK DAHA Ã‡EÅžÄ°TLÄ° HAREKET TÄ°PLERÄ°
        const MOVEMENT_PATTERNS = [
            // Spiral hareketler
            {
                name: 'spiral_right',
                type: 'spiral',
                angle: 0.25,
                radiusGrowth: 0.8,
                steps: 80
            },
            {
                name: 'spiral_left',
                type: 'spiral',
                angle: -0.25,
                radiusGrowth: 0.8,
                steps: 80
            },
            {
                name: 'slow_spiral',
                type: 'spiral',
                angle: 0.18,
                radiusGrowth: 0.6,
                steps: 90
            },
            {
                name: 'gentle_spiral',
                type: 'spiral',
                angle: 0.22,
                radiusGrowth: 1,
                steps: 85
            },
            // Yatay hareketler
            {
                name: 'horizontal_right',
                type: 'horizontal',
                direction: 1,
                speed: 1.8,
                steps: 90
            },
            {
                name: 'horizontal_left',
                type: 'horizontal',
                direction: -1,
                speed: 1.8,
                steps: 90
            },
            // Dikey hareketler
            {
                name: 'vertical_down',
                type: 'vertical',
                direction: 1,
                speed: 1.8,
                steps: 90
            },
            {
                name: 'vertical_up',
                type: 'vertical',
                direction: -1,
                speed: 1.8,
                steps: 90
            },
            // Ã‡apraz hareketler (kÃ¶ÅŸeden kÃ¶ÅŸeye)
            {
                name: 'corner_top_left_to_bottom_right',
                type: 'corner',
                fromCorner: 'top-left',
                toCorner: 'bottom-right',
                steps: 100
            },
            {
                name: 'corner_top_right_to_bottom_left',
                type: 'corner',
                fromCorner: 'top-right',
                toCorner: 'bottom-left',
                steps: 100
            },
            {
                name: 'corner_bottom_left_to_top_right',
                type: 'corner',
                fromCorner: 'bottom-left',
                toCorner: 'top-right',
                steps: 100
            },
            {
                name: 'corner_bottom_right_to_top_left',
                type: 'corner',
                fromCorner: 'bottom-right',
                toCorner: 'top-left',
                steps: 100
            },
            // Kenardan kenara
            {
                name: 'left_to_right',
                type: 'edge',
                fromEdge: 'left',
                toEdge: 'right',
                steps: 95
            },
            {
                name: 'right_to_left',
                type: 'edge',
                fromEdge: 'right',
                toEdge: 'left',
                steps: 95
            },
            {
                name: 'top_to_bottom',
                type: 'edge',
                fromEdge: 'top',
                toEdge: 'bottom',
                steps: 95
            },
            {
                name: 'bottom_to_top',
                type: 'edge',
                fromEdge: 'bottom',
                toEdge: 'top',
                steps: 95
            },
            // DalgalÄ± hareketler
            {
                name: 'wave_horizontal',
                type: 'wave',
                direction: 1,
                waveStrength: 20,
                speed: 1.5,
                steps: 100
            },
            {
                name: 'wave_vertical',
                type: 'wave',
                direction: -1,
                waveStrength: 20,
                speed: 1.5,
                steps: 100
            },
            // Zigzag
            {
                name: 'zigzag_horizontal',
                type: 'zigzag',
                direction: 'horizontal',
                speed: 1.6,
                steps: 95
            },
            {
                name: 'zigzag_vertical',
                type: 'zigzag',
                direction: 'vertical',
                speed: 1.6,
                steps: 95
            },
            // Daire Ã§izme
            {
                name: 'circle_clockwise',
                type: 'circle',
                direction: 1,
                radius: 80,
                steps: 100
            },
            {
                name: 'circle_counter',
                type: 'circle',
                direction: -1,
                radius: 80,
                steps: 100
            },
            // S harfi ÅŸeklinde
            {
                name: 's_curve',
                type: 's-curve',
                steps: 95
            },
            // Random walk (organik)
            {
                name: 'organic_flow',
                type: 'organic',
                steps: 90
            }
        ];

        // ðŸŽ¹ PÄ°YANO MESAJ SÄ°STEMÄ° - Ã‡OK RENKLÄ° FLUIDS!
        window.addEventListener('message', (event) => {
            if (event.data.type === 'pianoKeyPress') {
                const colors = event.data.colors || [];
                const key = event.data.key;
                
                if (colors.length === 0) return;
                
                // En canlÄ± renkleri al
                const bestColors = selectBestColors(colors);
                
                if (bestColors.length === 0) return;
                
                // ðŸŒˆ 3-5 FARKLI FLUÄ°D OLUÅžTUR!
                const numFluids = Math.floor(Math.random() * 3) + 3; // 3-5 arasÄ±
                
                console.log(`ðŸŽ¹ ${key.toUpperCase()} â†’ ${numFluids} multi-color fluid!`);
                
                for (let i = 0; i < numFluids; i++) {
                    // Her fluid iÃ§in FARKLI hareket paterni
                    const pattern = MOVEMENT_PATTERNS[Math.floor(Math.random() * MOVEMENT_PATTERNS.length)];
                    
                    // Spawn noktasÄ±nÄ± pattern'e gÃ¶re belirle
                    let startX, startY;
                    if (pattern.type === 'corner' || pattern.type === 'edge') {
                        const coords = getPatternStartPoint(pattern);
                        startX = coords.x;
                        startY = coords.y;
                    } else {
                        // Random spawn
                        startX = Math.random() * (parentWidth || window.innerWidth);
                        startY = Math.random() * (parentHeight || window.innerHeight);
                    }
                    
                    console.log(`  ðŸŽ¨ Fluid ${i+1}: ${bestColors.length} colors - ${pattern.name}`);
                    
                    // KÄ±sa gecikme ile fluid oluÅŸtur
                    setTimeout(() => {
                        createMultiColorFluid(startX, startY, bestColors, pattern);
                    }, i * 50);
                }
            }
        });

        // Pattern'e gÃ¶re baÅŸlangÄ±Ã§ noktasÄ± belirle
        function getPatternStartPoint(pattern) {
            const width = parentWidth || window.innerWidth;
            const height = parentHeight || window.innerHeight;
            
            if (pattern.type === 'corner') {
                const corners = {
                    'top-left': { x: 0, y: 0 },
                    'top-right': { x: width, y: 0 },
                    'bottom-left': { x: 0, y: height },
                    'bottom-right': { x: width, y: height }
                };
                return corners[pattern.fromCorner];
            }
            
            if (pattern.type === 'edge') {
                const edges = {
                    'left': { x: 0, y: height * Math.random() },
                    'right': { x: width, y: height * Math.random() },
                    'top': { x: width * Math.random(), y: 0 },
                    'bottom': { x: width * Math.random(), y: height }
                };
                return edges[pattern.fromEdge];
            }
            
            return { x: width / 2, y: height / 2 };
        }

        // PNG rengini Cables SplatColor'a set et
        function setPianoColor(color) {
            if (typeof CABLES === 'undefined' || !CABLES.patch) return;
            
            try {
                const normalizedColor = [
                    color.r / 255,
                    color.g / 255,
                    color.b / 255
                ];
                CABLES.patch.setVariable('SplatColor', normalizedColor);
            } catch(e) {
                console.warn('Renk set hatasÄ±');
            }
        }

        // ðŸŒˆ Ã‡OK RENKLÄ° ORGANIK FLUID - HER ADIMDA RENK DEÄžÄ°ÅžÄ°R!
        function createMultiColorFluid(startX, startY, colors, pattern) {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth;
            const height = parentHeight || window.innerHeight;
            
            // Hedef noktayÄ± belirle
            let targetX = startX;
            let targetY = startY;
            
            if (pattern.type === 'corner') {
                const corners = {
                    'top-left': { x: 0, y: 0 },
                    'top-right': { x: width, y: 0 },
                    'bottom-left': { x: 0, y: height },
                    'bottom-right': { x: width, y: height }
                };
                targetX = corners[pattern.toCorner].x;
                targetY = corners[pattern.toCorner].y;
            } else if (pattern.type === 'edge') {
                const edges = {
                    'left': { x: 0, y: height * Math.random() },
                    'right': { x: width, y: height * Math.random() },
                    'top': { x: width * Math.random(), y: 0 },
                    'bottom': { x: width * Math.random(), y: height }
                };
                targetX = edges[pattern.toEdge].x;
                targetY = edges[pattern.toEdge].y;
            }
            
            let angle = 0;
            let radius = 0;
            let step = 0;
            let colorIndex = 0;
            
            const maxSteps = pattern.steps;
            
            // Ä°LK RENK SET ET VE HEMEN BAÅžLA
            setPianoColor(colors[0]);
            
            canvas.dispatchEvent(new MouseEvent('mousedown', {
                clientX: startX,
                clientY: startY,
                button: 0,
                buttons: 1,
                bubbles: true
            }));
            
            // Hemen ilk hareketi yap (renk topu oluÅŸmasÄ±n, direkt fluid baÅŸlasÄ±n)
            setTimeout(() => {
                let firstX = startX;
                let firstY = startY;
                
                if (pattern.type === 'horizontal') {
                    firstX = startX + (pattern.direction * 2);
                } else if (pattern.type === 'vertical') {
                    firstY = startY + (pattern.direction * 2);
                } else if (pattern.type === 'corner' || pattern.type === 'edge') {
                    const dx = targetX - startX;
                    const dy = targetY - startY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    firstX = startX + (dx / distance) * 3;
                    firstY = startY + (dy / distance) * 3;
                } else {
                    firstX = startX + 2;
                    firstY = startY + 1;
                }
                
                canvas.dispatchEvent(new MouseEvent('mousemove', {
                    clientX: firstX,
                    clientY: firstY,
                    button: 0,
                    buttons: 1,
                    bubbles: true
                }));
            }, 5);
            
            const interval = setInterval(() => {
                // ðŸŽ¨ HER 3-4 ADIMDA RENK DEÄžÄ°ÅžTÄ°R (daha sÄ±k renk deÄŸiÅŸimi)
                if (step % 3 === 0) {
                    colorIndex = (colorIndex + 1) % colors.length;
                    setPianoColor(colors[colorIndex]);
                }
                
                let x, y;
                
                // Hareket tipine gÃ¶re koordinat hesapla
                if (pattern.type === 'horizontal') {
                    x = startX + (step * pattern.speed * pattern.direction);
                    y = startY + Math.sin(step * 0.1) * 8;
                } 
                else if (pattern.type === 'vertical') {
                    x = startX + Math.sin(step * 0.1) * 8;
                    y = startY + (step * pattern.speed * pattern.direction);
                } 
                else if (pattern.type === 'corner' || pattern.type === 'edge') {
                    // BaÅŸlangÄ±Ã§tan hedefe doÄŸru linear hareket
                    const progress = step / maxSteps;
                    x = startX + (targetX - startX) * progress;
                    y = startY + (targetY - startY) * progress;
                    // Hafif organik dalgalanma ekle
                    x += Math.sin(step * 0.15) * 5;
                    y += Math.cos(step * 0.15) * 5;
                }
                else if (pattern.type === 'wave') {
                    x = startX + (step * pattern.speed * pattern.direction);
                    y = startY + Math.sin(step * 0.2) * pattern.waveStrength;
                } 
                else if (pattern.type === 'zigzag') {
                    if (pattern.direction === 'horizontal') {
                        const zigzagPhase = Math.floor(step / 15) % 2;
                        x = startX + (step * pattern.speed);
                        y = startY + (zigzagPhase === 0 ? step * 1.2 : -step * 1.2);
                    } else {
                        const zigzagPhase = Math.floor(step / 15) % 2;
                        x = startX + (zigzagPhase === 0 ? step * 1.2 : -step * 1.2);
                        y = startY + (step * pattern.speed);
                    }
                }
                else if (pattern.type === 'circle') {
                    const angleStep = (Math.PI * 2) / maxSteps;
                    angle = angleStep * step * pattern.direction;
                    x = startX + Math.cos(angle) * pattern.radius;
                    y = startY + Math.sin(angle) * pattern.radius;
                }
                else if (pattern.type === 's-curve') {
                    const progress = step / maxSteps;
                    x = startX + (progress * width * 0.6);
                    y = startY + Math.sin(progress * Math.PI * 3) * (height * 0.3);
                }
                else if (pattern.type === 'organic') {
                    // YumuÅŸak organic flow
                    x = startX + (step * 1.5) + Math.sin(step * 0.12) * 15;
                    y = startY + (step * 0.8) + Math.cos(step * 0.15) * 15;
                }
                else if (pattern.type === 'spiral') {
                    // Spiral hareketi
                    angle += pattern.angle;
                    radius += pattern.radiusGrowth;
                    x = startX + Math.cos(angle) * radius;
                    y = startY + Math.sin(angle) * radius;
                }
                
                canvas.dispatchEvent(new MouseEvent('mousemove', {
                    clientX: x,
                    clientY: y,
                    button: 0,
                    buttons: 1,
                    bubbles: true
                }));
                
                step++;
                if (step >= maxSteps) {
                    clearInterval(interval);
                    
                    canvas.dispatchEvent(new MouseEvent('mouseup', {
                        clientX: x,
                        clientY: y,
                        button: 0,
                        buttons: 0,
                        bubbles: true
                    }));
                }
            }, 25); // Daha yavaÅŸ ve organik hareket
        }

        window.addEventListener('DOMContentLoaded', () => {
            forceFullScreenCanvas();
        });

        document.addEventListener("CABLES.jsLoaded", function (event) {
            forceFullScreenCanvas();
            
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "js/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true }
            });
            
            hideStatsPanels();
            setTimeout(forceFullScreenCanvas, 50);
        });

        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
        
        setInterval(hideStatsPanels, 1000);
        setInterval(forceFullScreenCanvas, 2000);
        
        window.addEventListener('resize', () => {
            try {
                if (window.parent !== window) {
                    parentWidth = window.parent.innerWidth;
                    parentHeight = window.parent.innerHeight;
                }
            } catch(e) {
                parentWidth = window.innerWidth;
                parentHeight = window.innerHeight;
            }
            forceFullScreenCanvas();
        });

        window.addEventListener('message', (event) => {
            if (event.data.type === 'parentResize') {
                parentWidth = event.data.width;
                parentHeight = event.data.height;
                forceFullScreenCanvas();
            }
        });
    </script>
</body>
</html>
