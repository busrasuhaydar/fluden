<!DOCTYPE html>
<html lang="en">
<head>
    <title>Piano Fluid - Pouring Art</title>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; user-select:none; }
        html, body { width:100%; height:100%; overflow:hidden; background:transparent; }
        #glcanvas { position:absolute; top:0; left:0; width:100%; height:100%; outline:0; background:transparent; }
        div[style*="position: absolute"], div[style*="fixed"], .cables-stats, .stats-panel { display:none !important; visibility:hidden !important; }
    </style>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<canvas id="glcanvas" tabindex="1"></canvas>

<script type="text/javascript" src="js/patch.js" async></script>
<script>
let parentWidth = window.innerWidth;
let parentHeight = window.innerHeight;
if (window.parent !== window) {
    try { parentWidth = window.parent.innerWidth; parentHeight = window.parent.innerHeight; } catch(e){}
}

function forceFullScreenCanvas(){
    const canvas = document.getElementById('glcanvas');
    const width = parentWidth || window.innerWidth;
    const height = parentHeight || window.innerHeight;
    canvas.width = width; canvas.height = height;
    canvas.style.width = width+'px'; canvas.style.height = height+'px';
    canvas.style.position='absolute'; canvas.style.top='0'; canvas.style.left='0';
}

function patchInitialized(patch){ hideStatsPanels(); forceFullScreenCanvas(); }
function patchFinishedLoading(patch){ hideStatsPanels(); forceFullScreenCanvas(); }
function hideStatsPanels(){ setTimeout(()=>{document.querySelectorAll('div').forEach(d=>{const s=d.style;if(s&& (s.position=='absolute'||s.position=='fixed')){s.display='none';s.visibility='hidden';}});},100); }

function selectBestColors(colors){
    if(!colors || colors.length==0) return [{r:255,g:100,b:200},{r:100,g:200,b:255},{r:255,g:200,b:100}];
    const vibrant = colors.filter(c=>{const b=(c.r+c.g+c.b)/3,s=Math.max(c.r,c.g,c.b)-Math.min(c.r,c.g,c.b); return b>50&&b<220&&s>40;});
    const working = vibrant.length>0?vibrant:colors;
    return working.sort((a,b)=>Math.max(b.r,b.g,b.b)-Math.min(b.r,b.g,b.b)- (Math.max(a.r,a.g,a.b)-Math.min(a.r,a.g,a.b))).slice(0,15);
}

// Yeni patternler ve otomatik sürükleme
const MOVEMENT_PATTERNS = [
    {name:'gentle_spiral_right',type:'expanding_spiral',direction:1,startRadius:5,endRadius:150,steps:250,speed:0.7},
    {name:'gentle_spiral_left',type:'expanding_spiral',direction:-1,startRadius:5,endRadius:150,steps:250,speed:0.7},
    {name:'slow_large_circle',type:'circle',direction:1,radius:180,steps:280,speed:0.7},
    {name:'slow_medium_circle',type:'circle',direction:-1,radius:120,steps:260,speed:0.7},
    {name:'smooth_wave',type:'sine_wave',direction:'horizontal',amplitude:80,frequency:0.06,speed:0.7,steps:270},
    {name:'organic_pour',type:'organic',smoothness:0.85,speed:0.7,steps:260},
    {name:'lissajous_smooth',type:'lissajous',xFreq:2,yFreq:3,radius:120,steps:300,speed:0.7}
];

// Tuş basınca fluid tetikle
window.addEventListener('message', event=>{
    if(event.data.type=='pianoKeyPress'){
        const colors = event.data.colors||[];
        const key = event.data.key;
        if(colors.length==0) return;
        const bestColors = selectBestColors(colors);
        const numFluids = Math.floor(Math.random()*3)+3;
        for(let i=0;i<numFluids;i++){
            const pattern = MOVEMENT_PATTERNS[Math.floor(Math.random()*MOVEMENT_PATTERNS.length)];
            const startX = Math.random()*(parentWidth||window.innerWidth);
            const startY = Math.random()*(parentHeight||window.innerHeight);
            setTimeout(()=>{ createProfessionalFluid(startX,startY,bestColors,pattern); }, i*60);
        }
    }
});

function setPianoColor(color){
    if(typeof CABLES==='undefined' || !CABLES.patch) return;
    try{ CABLES.patch.setVariable('SplatColor',[color.r/255,color.g/255,color.b/255]); }catch(e){}
}

function createProfessionalFluid(startX,startY,colors,pattern){
    const canvas = document.getElementById('glcanvas');
    if(!canvas) return;
    const width = parentWidth || window.innerWidth;
    const height = parentHeight || window.innerHeight;
    let step=0, colorIndex=0, maxSteps=pattern.steps;
    let prevVelX=0, prevVelY=0;

    setPianoColor(colors[0]); // ilk renk

    // Başlangıç pozisyonu
    const startPos = calculatePosition(startX,startY,0,pattern,width,height,Math.random()*1000,Math.random()*1000,0,0);
    let currentX=startPos.x, currentY=startPos.y;
    prevVelX=startPos.velX||0; prevVelY=startPos.velY||0;

    canvas.dispatchEvent(new MouseEvent('mousedown',{clientX:currentX,clientY:currentY,button:0,buttons:1,bubbles:true,cancelable:true}));

    const interval = setInterval(()=>{
        step++;
        colorIndex=(colorIndex+1)%colors.length;
        setPianoColor(colors[colorIndex]);

        const newPos = calculatePosition(startX,startY,step,pattern,width,height,Math.random()*1000,Math.random()*1000,prevVelX,prevVelY);
        currentX=newPos.x; currentY=newPos.y;
        prevVelX=newPos.velX||0; prevVelY=newPos.velY||0;

        canvas.dispatchEvent(new MouseEvent('mousemove',{clientX:currentX,clientY:currentY,button:0,buttons:1,bubbles:true,cancelable:true}));

        if(step>=maxSteps){
            clearInterval(interval);
            canvas.dispatchEvent(new MouseEvent('mouseup',{clientX:currentX,clientY:currentY,button:0,buttons:0,bubbles:true,cancelable:true}));
        }
    },25);
}

function calculatePosition(startX,startY,step,pattern,width,height,noiseX,noiseY,prevVelX,prevVelY){
    let x,y;
    const progress=step/pattern.steps;
    switch(pattern.type){
        case 'circle':
            const angleCircle=(step/pattern.steps)*Math.PI*2*pattern.direction;
            x=startX+Math.cos(angleCircle)*pattern.radius;
            y=startY+Math.sin(angleCircle)*pattern.radius;
            break;
        case 'expanding_spiral':
            const angleExpand=(step/pattern.steps)*Math.PI*6*pattern.direction;
            const radiusExpand=pattern.startRadius+(pattern.endRadius-pattern.startRadius)*progress;
            x=startX+Math.cos(angleExpand)*radiusExpand;
            y=startY+Math.sin(angleExpand)*radiusExpand;
            break;
        case 'sine_wave':
            if(pattern.direction==='horizontal'){ x=startX+step*pattern.speed; y=startY+Math.sin(step*pattern.frequency)*pattern.amplitude; }
            else { x=startX+Math.sin(step*pattern.frequency)*pattern.amplitude; y=startY+step*pattern.speed; }
            break;
        case 'lissajous':
            const t=progress*Math.PI*2;
            x=startX+Math.sin(pattern.xFreq*t)*pattern.radius;
            y=startY+Math.sin(pattern.yFreq*t)*pattern.radius;
            break;
        case 'organic':
            const targetVelX=(Math.random()-0.5)*pattern.speed*3;
            const targetVelY=(Math.random()-0.5)*pattern.speed*3;
            const velX=prevVelX*pattern.smoothness+targetVelX*(1-pattern.smoothness);
            const velY=prevVelY*pattern.smoothness+targetVelY*(1-pattern.smoothness);
            x=startX+step*pattern.speed+velX*5;
            y=startY+velY*5;
            return {x,y,velX,velY};
        default: x=startX;y=startY;
    }
    return {x,y};
}

window.addEventListener('DOMContentLoaded',()=>{ forceFullScreenCanvas(); });
document.addEventListener("CABLES.jsLoaded",()=>{
    CABLES.patch=new CABLES.Patch({
        patch:CABLES.exportedPatch,
        "prefixAssetPath":"",
        "assetPath":"assets/",
        "jsPath":"js/",
        "glCanvasId":"glcanvas",
        "glCanvasResizeToWindow":true,
        "onError":()=>{},
        "onPatchLoaded":patchInitialized,
        "onFinishedLoading":patchFinishedLoading,
        "canvas":{"alpha":true,"premultipliedAlpha":true}
    });
    hideStatsPanels();
    setTimeout(forceFullScreenCanvas,50);
});

document.getElementById('glcanvas').addEventListener('touchmove', e=>{e.preventDefault();}, false);
window.addEventListener('resize', ()=>{
    try{ if(window.parent!==window){ parentWidth=window.parent.innerWidth; parentHeight=window.parent.innerHeight; } }catch(e){ parentWidth=window.innerWidth; parentHeight=window.innerHeight; }
    forceFullScreenCanvas();
});
window.addEventListener('message', event=>{ if(event.data.type==='parentResize'){ parentWidth=event.data.width; parentHeight=event.data.height; forceFullScreenCanvas(); }});
</script>
</body>
</html>
