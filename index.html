<!DOCTYPE html>
<html lang="en">
<head>
    <title>Piano Fluid - Enhanced</title>
    <style>
        * {
            margin: 0 !important;
            padding: 0 !important;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            box-sizing: border-box;
        }

        html, body {
            width: 100vw !important;
            height: 100vh !important;
            overflow: hidden !important;
            background-color: #000;
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            position: fixed;
            top: 0;
            left: 0;
        }

        canvas {
            display: block;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            outline: 0;
        }

        /* FPS/CPU yazÄ±larÄ±nÄ± gizle */
        div[style*="position: absolute"],
        div[style*="fixed"],
        .cables-stats,
        .stats-panel {
            display: none !important;
            visibility: hidden !important;
        }

    </style>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1">
</head>
<body>
    <canvas id="glcanvas" tabindex="1"></canvas>

    <script type="text/javascript" src="js/patch.js" async></script>

    <script type="text/javascript">

        function showError(initiator,...args) {
            // Silent
        }

        function patchInitialized(patch) {
            console.log('âœ… Fluid hazÄ±r!');
            // Stats panellerini gizle
            hideStatsPanels();
        }

        function patchFinishedLoading(patch) {
            console.log('ðŸŽ¨ YÃ¼kleme tamamlandÄ±!');
            hideStatsPanels();
        }

        // FPS/CPU panellerini gizle
        function hideStatsPanels() {
            setTimeout(() => {
                const statsDivs = document.querySelectorAll('div');
                statsDivs.forEach(div => {
                    const style = div.getAttribute('style');
                    if (style && (style.includes('position: absolute') || style.includes('position: fixed'))) {
                        div.style.display = 'none';
                        div.style.visibility = 'hidden';
                    }
                });
            }, 100);
        }

        // ðŸŽ¨ GELÄ°ÅžMÄ°Åž RENK ANALÄ°ZÄ° - PNG'den en belirgin 20 rengi Ã§Ä±kar
        async function extractDominantColors(imageUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Performans iÃ§in kÃ¼Ã§Ã¼lt
                    const maxSize = 150;
                    const scale = Math.min(maxSize / img.width, maxSize / img.height);
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // K-means clustering ile en belirgin 10 ana renk
                    const dominantColors = getDominantColors(imageData.data, 10);
                    
                    // Her ana renk iÃ§in parlak/orta/koyu varyasyonlar ekle
                    const allColors = [];
                    dominantColors.forEach(color => {
                        allColors.push(color); // Orijinal
                        allColors.push(adjustBrightness(color, 1.3)); // Parlak
                        allColors.push(adjustBrightness(color, 0.7)); // Koyu
                    });
                    
                    // En belirgin 20 rengi dÃ¶ndÃ¼r
                    resolve(allColors.slice(0, 20));
                };
                
                img.onerror = () => resolve([{r: 255, g: 100, b: 200}]);
                img.src = imageUrl;
            });
        }

        // K-means color quantization
        function getDominantColors(pixels, k) {
            const colors = [];
            
            // Her 4. pikseli al (RGBA)
            for (let i = 0; i < pixels.length; i += 16) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const a = pixels[i + 3];
                
                // Åžeffaf ve Ã§ok koyu/aÃ§Ä±k pikselleri atla
                if (a < 50 || (r + g + b < 30) || (r + g + b > 750)) continue;
                
                colors.push({r, g, b});
            }
            
            if (colors.length < k) return colors;
            
            // Basit k-means
            let centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push(colors[Math.floor(Math.random() * colors.length)]);
            }
            
            // 5 iterasyon
            for (let iter = 0; iter < 5; iter++) {
                const clusters = Array.from({length: k}, () => []);
                
                colors.forEach(color => {
                    let minDist = Infinity;
                    let closest = 0;
                    
                    centroids.forEach((centroid, idx) => {
                        const dist = colorDistance(color, centroid);
                        if (dist < minDist) {
                            minDist = dist;
                            closest = idx;
                        }
                    });
                    
                    clusters[closest].push(color);
                });
                
                // Yeni centroidler
                centroids = clusters.map(cluster => {
                    if (cluster.length === 0) return centroids[0];
                    
                    const sum = cluster.reduce((acc, c) => ({
                        r: acc.r + c.r,
                        g: acc.g + c.g,
                        b: acc.b + c.b
                    }), {r: 0, g: 0, b: 0});
                    
                    return {
                        r: Math.round(sum.r / cluster.length),
                        g: Math.round(sum.g / cluster.length),
                        b: Math.round(sum.b / cluster.length)
                    };
                });
            }
            
            // Renklilik/doygunluÄŸa gÃ¶re sÄ±rala (en canlÄ± renkler Ã¶nce)
            return centroids.sort((a, b) => colorSaturation(b) - colorSaturation(a));
        }

        function colorDistance(c1, c2) {
            return Math.sqrt(
                Math.pow(c1.r - c2.r, 2) +
                Math.pow(c1.g - c2.g, 2) +
                Math.pow(c1.b - c2.b, 2)
            );
        }

        function colorSaturation(color) {
            const max = Math.max(color.r, color.g, color.b);
            const min = Math.min(color.r, color.g, color.b);
            return max - min;
        }

        function adjustBrightness(color, factor) {
            return {
                r: Math.min(255, Math.round(color.r * factor)),
                g: Math.min(255, Math.round(color.g * factor)),
                b: Math.min(255, Math.round(color.b * factor))
            };
        }

        // ðŸŽ¹ PÄ°YANO MESAJ SÄ°STEMÄ°
        window.addEventListener('message', async (event) => {
            if (event.data.type === 'pianoKeyPress') {
                const key = event.data.key;
                const imageUrl = event.data.imageUrl;
                
                if (!imageUrl) return;
                
                // PNG'den en belirgin 20 rengi Ã§Ä±kar
                const colors = await extractDominantColors(imageUrl);
                
                if (colors.length === 0) return;
                
                // Random bir renk seÃ§ (20 renk iÃ§inden)
                const randomColor = colors[Math.floor(Math.random() * colors.length)];
                
                console.log('ðŸŽ¹', key.toUpperCase(), 'â†’', `rgb(${randomColor.r},${randomColor.g},${randomColor.b})`);
                
                // Rengi Cables'e gÃ¶nder
                setPianoColor(randomColor);
                
                // FARKLI NOKTALARDA spawn et
                const randomX = Math.random() * window.innerWidth;
                const randomY = Math.random() * window.innerHeight;
                
                createPianoSpiral(randomX, randomY);
            }
        });

        // PNG rengini Cables SplatColor'a set et
        function setPianoColor(color) {
            if (typeof CABLES === 'undefined' || !CABLES.patch) return;
            
            try {
                const normalizedColor = [
                    color.r / 255,
                    color.g / 255,
                    color.b / 255
                ];
                CABLES.patch.setVariable('SplatColor', normalizedColor);
            } catch(e) {
                console.warn('Renk set hatasÄ±');
            }
        }

        // Spiral mouse hareketi
        function createPianoSpiral(startX, startY) {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            canvas.dispatchEvent(new MouseEvent('mousedown', {
                clientX: startX,
                clientY: startY,
                button: 0,
                buttons: 1,
                bubbles: true
            }));
            
            let angle = 0;
            let radius = 0;
            let step = 0;
            const maxSteps = 30;
            
            const interval = setInterval(() => {
                angle += 0.6;
                radius += 3;
                
                const x = startX + Math.cos(angle) * radius;
                const y = startY + Math.sin(angle) * radius;
                
                canvas.dispatchEvent(new MouseEvent('mousemove', {
                    clientX: x,
                    clientY: y,
                    button: 0,
                    buttons: 1,
                    bubbles: true
                }));
                
                step++;
                if (step >= maxSteps) {
                    clearInterval(interval);
                    
                    canvas.dispatchEvent(new MouseEvent('mouseup', {
                        clientX: x,
                        clientY: y,
                        button: 0,
                        buttons: 0,
                        bubbles: true
                    }));
                }
            }, 16);
        }

        document.addEventListener("CABLES.jsLoaded", function (event) {
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "js/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true }
            });
            
            hideStatsPanels();
        });

        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
        
        // Periyodik olarak stats panellerini kontrol et
        setInterval(hideStatsPanels, 1000);
    </script>
</body>
</html>
