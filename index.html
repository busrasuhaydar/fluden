<!DOCTYPE html>
<html lang="en">
<head>
    <title>Piano Fluid - Living Art</title>
    <style>
        * {
            margin: 0 !important;
            padding: 0 !important;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            box-sizing: border-box !important;
        }

        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent !important;
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            position: relative;
        }

        #glcanvas {
            display: block !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            outline: 0 !important;
            transform: none !important;
            background: transparent !important;
        }

        div[style*="position: absolute"],
        div[style*="fixed"],
        .cables-stats,
        .stats-panel {
            display: none !important;
            visibility: hidden !important;
        }
    </style>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
</head>
<body>
    <canvas id="glcanvas" tabindex="1"></canvas>
    <script type="text/javascript" src="js/patch.js" async></script>
    <script type="text/javascript">

        function showError(initiator,...args) {}

        let parentWidth = window.innerWidth;
        let parentHeight = window.innerHeight;

        if (window.parent !== window) {
            try {
                parentWidth = window.parent.innerWidth;
                parentHeight = window.parent.innerHeight;
            } catch(e) {}
        }

        function forceFullScreenCanvas() {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth || document.documentElement.clientWidth;
            const height = parentHeight || window.innerHeight || document.documentElement.clientHeight;
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
        }

        function patchInitialized(patch) {
            console.log('âœ… Fluid hazÄ±r!');
            hideStatsPanels();
            forceFullScreenCanvas();
            
            setTimeout(forceFullScreenCanvas, 100);
            setTimeout(forceFullScreenCanvas, 500);
            setTimeout(forceFullScreenCanvas, 1000);
            setTimeout(forceFullScreenCanvas, 2000);
        }

        function patchFinishedLoading(patch) {
            console.log('ðŸŽ¨ YÃ¼kleme tamamlandÄ±!');
            hideStatsPanels();
            forceFullScreenCanvas();
        }

        function hideStatsPanels() {
            setTimeout(() => {
                const statsDivs = document.querySelectorAll('div');
                statsDivs.forEach(div => {
                    const style = div.getAttribute('style');
                    if (style && (style.includes('position: absolute') || style.includes('position: fixed'))) {
                        div.style.display = 'none';
                        div.style.visibility = 'hidden';
                    }
                });
            }, 100);
        }

        // ðŸŽ¨ EN DOMINANT VE CANLI RENKLERÄ° SEÃ‡
        function selectBestColors(colors) {
            if (!colors || colors.length === 0) {
                return [
                    {r: 255, g: 80, b: 180},
                    {r: 80, g: 180, b: 255},
                    {r: 255, g: 180, b: 80}
                ];
            }

            // Renkleri grupla ve en yaygÄ±n olanlarÄ± bul
            const colorMap = new Map();
            
            colors.forEach(c => {
                // Quantize colors to reduce similar colors
                const qr = Math.round(c.r / 30) * 30;
                const qg = Math.round(c.g / 30) * 30;
                const qb = Math.round(c.b / 30) * 30;
                const key = `${qr},${qg},${qb}`;
                
                const brightness = (c.r + c.g + c.b) / 3;
                const saturation = Math.max(c.r, c.g, c.b) - Math.min(c.r, c.g, c.b);
                
                // Sadece canlÄ±, orta parlaklÄ±kta renkler
                if (brightness > 60 && brightness < 200 && saturation > 50) {
                    if (!colorMap.has(key)) {
                        colorMap.set(key, { color: c, count: 0, saturation });
                    }
                    colorMap.get(key).count++;
                }
            });

            // En yaygÄ±n ve en doygun renkleri al
            const sortedColors = Array.from(colorMap.values())
                .sort((a, b) => {
                    // Ã–nce count'a gÃ¶re, sonra saturation'a gÃ¶re
                    const countDiff = b.count - a.count;
                    if (Math.abs(countDiff) > 5) return countDiff;
                    return b.saturation - a.saturation;
                })
                .slice(0, 5) // En fazla 5 ana renk
                .map(item => {
                    // Renkleri biraz boost et (vibrant tut)
                    const c = item.color;
                    const max = Math.max(c.r, c.g, c.b);
                    const boost = 1.15; // %15 daha vibrant
                    
                    return {
                        r: Math.min(255, Math.round(c.r * boost)),
                        g: Math.min(255, Math.round(c.g * boost)),
                        b: Math.min(255, Math.round(c.b * boost))
                    };
                });

            if (sortedColors.length === 0) {
                // Fallback - en doygun renkleri al
                return colors
                    .filter(c => {
                        const sat = Math.max(c.r, c.g, c.b) - Math.min(c.r, c.g, c.b);
                        return sat > 40;
                    })
                    .sort((a, b) => {
                        const satA = Math.max(a.r, a.g, a.b) - Math.min(a.r, a.g, a.b);
                        const satB = Math.max(b.r, b.g, b.b) - Math.min(b.r, b.g, b.b);
                        return satB - satA;
                    })
                    .slice(0, 5);
            }

            return sortedColors;
        }

        // ðŸŒŠ HAREKET PATTERNLERÄ°
        const FLOW_PATTERNS = [
            { type: 'circle', radius: 160, clockwise: true },
            { type: 'circle', radius: 160, clockwise: false },
            { type: 'circle', radius: 130, clockwise: true },
            { type: 'spiral', startRadius: 50, endRadius: 150, clockwise: true },
            { type: 'spiral', startRadius: 150, endRadius: 50, clockwise: false },
            { type: 's_curve', amplitude: 90, length: 320 },
            { type: 'wave', amplitude: 80, wavelength: 220, length: 360 }
        ];

        // ðŸŽ¹ PÄ°YANO MESAJ SÄ°STEMÄ°
        window.addEventListener('message', (event) => {
            if (event.data.type === 'pianoKeyPress') {
                const colors = event.data.colors || [];
                const key = event.data.key;
                
                if (colors.length === 0) return;
                
                const bestColors = selectBestColors(colors);
                if (bestColors.length === 0) return;
                
                console.log(`ðŸŽ¹ ${key.toUpperCase()} â†’ ${bestColors.length} dominant colors`);
                
                // 1 fluid (temiz ve net)
                const pattern = FLOW_PATTERNS[Math.floor(Math.random() * FLOW_PATTERNS.length)];
                
                const startX = Math.random() * 0.3 * parentWidth + 0.35 * parentWidth;
                const startY = Math.random() * 0.3 * parentHeight + 0.35 * parentHeight;
                
                createFluidFlow(startX, startY, bestColors, pattern);
            }
        });

        function setPianoColor(color) {
            if (typeof CABLES === 'undefined' || !CABLES.patch) return;
            
            try {
                const normalizedColor = [
                    color.r / 255,
                    color.g / 255,
                    color.b / 255
                ];
                CABLES.patch.setVariable('SplatColor', normalizedColor);
            } catch(e) {}
        }

        // ðŸŽ¨ RENK BLENDING
        function blendColors(color1, color2, ratio) {
            return {
                r: Math.round(color1.r * (1 - ratio) + color2.r * ratio),
                g: Math.round(color1.g * (1 - ratio) + color2.g * ratio),
                b: Math.round(color1.b * (1 - ratio) + color2.b * ratio)
            };
        }

        // ðŸŒŠ FLUID AKIÅžI - FIXED DURATION: 3.5 SANÄ°YE
        function createFluidFlow(startX, startY, colors, pattern) {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth;
            const height = parentHeight || window.innerHeight;
            
            // SABÄ°T SÃœRE: 200 frame Ã— 18ms = 3.6 saniye
            const TOTAL_FRAMES = 200;
            const FRAME_DURATION = 18; // ms
            
            let frameIndex = 0;
            
            // Path hesapla
            const basePath = generateBasePath(startX, startY, pattern, width, height, TOTAL_FRAMES);
            
            // Ä°lk rengi set et
            setPianoColor(colors[0]);
            
            // BAÅžLANGIÃ‡ POZÄ°SYONU - patlamayÄ± Ã¶nlemek iÃ§in
            // Ä°lk 15 frame'i atla, oradan baÅŸla
            const startFrame = Math.min(15, Math.floor(basePath.length * 0.1));
            let currentX = basePath[startFrame].x;
            let currentY = basePath[startFrame].y;
            
            console.log(`ðŸŽ¨ Fluid baÅŸlÄ±yor: ${TOTAL_FRAMES} frame, ${colors.length} renk`);
            
            // MOUSEDOWN - baÅŸlangÄ±Ã§
            canvas.dispatchEvent(new MouseEvent('mousedown', {
                clientX: currentX,
                clientY: currentY,
                button: 0,
                buttons: 1,
                bubbles: true
            }));
            
            // Ä°lk harekete baÅŸlamadan Ã¶nce kÄ±sa bekle
            setTimeout(() => {
                // ANA ANÄ°MASYON LOOP
                const animationInterval = setInterval(() => {
                    frameIndex++;
                    
                    // BitmiÅŸ mi kontrol et
                    if (frameIndex >= TOTAL_FRAMES - startFrame) {
                        clearInterval(animationInterval);
                        
                        // MOUSEUP - bitir
                        canvas.dispatchEvent(new MouseEvent('mouseup', {
                            clientX: currentX,
                            clientY: currentY,
                            button: 0,
                            buttons: 0,
                            bubbles: true
                        }));
                        
                        console.log('âœ… Fluid tamamlandÄ±');
                        return;
                    }
                    
                    const actualFrame = frameIndex + startFrame;
                    
                    // RENK BLENDING - smooth geÃ§iÅŸ
                    const progress = frameIndex / (TOTAL_FRAMES - startFrame);
                    const colorProgress = progress * (colors.length - 1);
                    const colorIndex = Math.floor(colorProgress);
                    const colorBlend = colorProgress - colorIndex;
                    
                    if (colorIndex < colors.length - 1) {
                        const blendedColor = blendColors(
                            colors[colorIndex], 
                            colors[colorIndex + 1], 
                            colorBlend
                        );
                        setPianoColor(blendedColor);
                    } else {
                        setPianoColor(colors[colors.length - 1]);
                    }
                    
                    // YENÄ° POZÄ°SYON
                    if (actualFrame < basePath.length) {
                        currentX = basePath[actualFrame].x;
                        currentY = basePath[actualFrame].y;
                        
                        // SÄ±nÄ±r kontrolÃ¼
                        currentX = Math.max(20, Math.min(width - 20, currentX));
                        currentY = Math.max(20, Math.min(height - 20, currentY));
                        
                        // MOUSEMOVE
                        canvas.dispatchEvent(new MouseEvent('mousemove', {
                            clientX: currentX,
                            clientY: currentY,
                            button: 0,
                            buttons: 1,
                            bubbles: true
                        }));
                    }
                    
                }, FRAME_DURATION);
            }, 60); // Smooth baÅŸlangÄ±Ã§ iÃ§in 60ms bekle
        }

        // ðŸŽ¨ BASE PATH GENERATOR - SPLÄ°NE OLMADAN (sÃ¼re kontrolÃ¼ iÃ§in)
        function generateBasePath(startX, startY, pattern, width, height, pointCount) {
            const points = [];
            
            // Perlin-like noise
            const noiseOffsetX = Math.random() * 1000;
            const noiseOffsetY = Math.random() * 1000;
            
            for (let i = 0; i < pointCount; i++) {
                const t = i / pointCount;
                let x, y;
                
                // Organic noise - hafif
                const noiseScale = 0.025;
                const noiseX = (Math.sin(i * noiseScale + noiseOffsetX) + 
                               Math.sin(i * noiseScale * 2.3 + noiseOffsetX * 1.4)) * 10;
                const noiseY = (Math.cos(i * noiseScale + noiseOffsetY) + 
                               Math.cos(i * noiseScale * 1.9 + noiseOffsetY * 1.7)) * 10;
                
                switch(pattern.type) {
                    case 'circle':
                        const angleCircle = t * Math.PI * 2 * (pattern.clockwise ? 1 : -1);
                        const breathe = 1 + Math.sin(t * Math.PI * 2.5) * 0.1;
                        x = startX + Math.cos(angleCircle) * pattern.radius * breathe + noiseX;
                        y = startY + Math.sin(angleCircle) * pattern.radius * breathe + noiseY;
                        break;
                        
                    case 'spiral':
                        const angleSpiral = t * Math.PI * 4 * (pattern.clockwise ? 1 : -1);
                        const radiusSpiral = pattern.startRadius + 
                                            (pattern.endRadius - pattern.startRadius) * t;
                        x = startX + Math.cos(angleSpiral) * radiusSpiral + noiseX;
                        y = startY + Math.sin(angleSpiral) * radiusSpiral + noiseY;
                        break;
                        
                    case 's_curve':
                        x = startX + (t - 0.5) * pattern.length + noiseX;
                        y = startY + Math.sin(t * Math.PI * 2) * pattern.amplitude + noiseY;
                        break;
                        
                    case 'wave':
                        const waveProgress = t * pattern.length;
                        x = startX + waveProgress * Math.cos(Math.PI / 6) + noiseX;
                        y = startY + waveProgress * Math.sin(Math.PI / 6) + 
                            Math.sin(waveProgress / pattern.wavelength * Math.PI * 2) * pattern.amplitude + noiseY;
                        break;
                        
                    default:
                        x = startX + t * 100;
                        y = startY + t * 100;
                }
                
                points.push({ x, y });
            }
            
            return points;
        }

        window.addEventListener('DOMContentLoaded', () => {
            forceFullScreenCanvas();
        });

        document.addEventListener("CABLES.jsLoaded", function (event) {
            forceFullScreenCanvas();
            
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "js/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true }
            });
            
            hideStatsPanels();
            setTimeout(forceFullScreenCanvas, 50);
        });

        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
        
        setInterval(hideStatsPanels, 1000);
        setInterval(forceFullScreenCanvas, 2000);
        
        window.addEventListener('resize', () => {
            try {
                if (window.parent !== window) {
                    parentWidth = window.parent.innerWidth;
                    parentHeight = window.parent.innerHeight;
                }
            } catch(e) {
                parentWidth = window.innerWidth;
                parentHeight = window.innerHeight;
            }
            forceFullScreenCanvas();
        });

        window.addEventListener('message', (event) => {
            if (event.data.type === 'parentResize') {
                parentWidth = event.data.width;
                parentHeight = event.data.height;
                forceFullScreenCanvas();
            }
        });
    </script>
</body>
</html>
