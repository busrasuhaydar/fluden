<!DOCTYPE html>
<html lang="en">
<head>
    <title>Piano Fluid - Living Art</title>
    <style>
        * {
            margin: 0 !important;
            padding: 0 !important;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            box-sizing: border-box !important;
        }

        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent !important;
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            position: relative;
        }

        #glcanvas {
            display: block !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            outline: 0 !important;
            transform: none !important;
            background: transparent !important;
        }

        div[style*="position: absolute"],
        div[style*="fixed"],
        .cables-stats,
        .stats-panel {
            display: none !important;
            visibility: hidden !important;
        }
    </style>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
</head>
<body>
    <canvas id="glcanvas" tabindex="1"></canvas>
    <script type="text/javascript" src="js/patch.js" async></script>
    <script type="text/javascript">

        function showError(initiator,...args) {}

        let parentWidth = window.innerWidth;
        let parentHeight = window.innerHeight;

        if (window.parent !== window) {
            try {
                parentWidth = window.parent.innerWidth;
                parentHeight = window.parent.innerHeight;
            } catch(e) {}
        }

        function forceFullScreenCanvas() {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth || document.documentElement.clientWidth;
            const height = parentHeight || window.innerHeight || document.documentElement.clientHeight;
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
        }

        function patchInitialized(patch) {
            console.log('âœ… Fluid hazÄ±r!');
            hideStatsPanels();
            forceFullScreenCanvas();
            
            setTimeout(forceFullScreenCanvas, 100);
            setTimeout(forceFullScreenCanvas, 500);
            setTimeout(forceFullScreenCanvas, 1000);
            setTimeout(forceFullScreenCanvas, 2000);
        }

        function patchFinishedLoading(patch) {
            console.log('ðŸŽ¨ YÃ¼kleme tamamlandÄ±!');
            hideStatsPanels();
            forceFullScreenCanvas();
        }

        function hideStatsPanels() {
            setTimeout(() => {
                const statsDivs = document.querySelectorAll('div');
                statsDivs.forEach(div => {
                    const style = div.getAttribute('style');
                    if (style && (style.includes('position: absolute') || style.includes('position: fixed'))) {
                        div.style.display = 'none';
                        div.style.visibility = 'hidden';
                    }
                });
            }, 100);
        }

        // ðŸŽ¨ PNG'DEN EN BASKIN VE CANLI RENKLERÄ° Ã‡OK DÄ°KKATLÄ° SEÃ‡
        function selectBestColors(colors) {
            if (!colors || colors.length === 0) {
                return [
                    {r: 255, g: 80, b: 180},
                    {r: 80, g: 180, b: 255},
                    {r: 255, g: 180, b: 80}
                ];
            }

            // 1. ADIM: Ã‡ok soluk ve Ã§ok koyu renkleri filtrele
            const validColors = colors.filter(c => {
                const brightness = (c.r + c.g + c.b) / 3;
                const saturation = Math.max(c.r, c.g, c.b) - Math.min(c.r, c.g, c.b);
                
                // Orta parlaklÄ±k ve yÃ¼ksek saturation
                return brightness > 70 && brightness < 190 && saturation > 60;
            });

            if (validColors.length === 0) {
                // Fallback: sadece saturation'a bak
                const fallback = colors.filter(c => {
                    const sat = Math.max(c.r, c.g, c.b) - Math.min(c.r, c.g, c.b);
                    return sat > 50;
                }).slice(0, 3);
                
                return fallback.map(c => makeVibrant(c));
            }

            // 2. ADIM: Renkleri HSL'ye Ã§evir ve grupla
            const colorGroups = new Map();
            
            validColors.forEach(c => {
                const hsl = rgbToHsl(c.r, c.g, c.b);
                // Hue'ya gÃ¶re grupla (30 derecelik aralÄ±klar)
                const hueGroup = Math.round(hsl.h / 30) * 30;
                const key = `${hueGroup}`;
                
                if (!colorGroups.has(key)) {
                    colorGroups.set(key, []);
                }
                colorGroups.get(key).push({ color: c, hsl: hsl });
            });

            // 3. ADIM: Her gruptan EN BASKIN rengi al
            const dominantColors = [];
            
            for (const [hueGroup, groupColors] of colorGroups.entries()) {
                // Grup iÃ§inde en doygun ve en parlak olanÄ± seÃ§
                const best = groupColors.sort((a, b) => {
                    const scoreA = a.hsl.s * 0.7 + a.hsl.l * 0.3;
                    const scoreB = b.hsl.s * 0.7 + b.hsl.l * 0.3;
                    return scoreB - scoreA;
                })[0];
                
                dominantColors.push({
                    color: best.color,
                    hsl: best.hsl,
                    count: groupColors.length // KaÃ§ piksel var bu renkte
                });
            }

            // 4. ADIM: En yaygÄ±n 3-5 rengi al
            const finalColors = dominantColors
                .sort((a, b) => b.count - a.count) // En yaygÄ±n olanlar Ã¶nce
                .slice(0, 4) // En fazla 4 renk
                .map(item => makeVibrant(item.color)); // Hepsini vibrant yap

            console.log(`ðŸŽ¨ ${finalColors.length} baskÄ±n renk seÃ§ildi`);
            return finalColors;
        }

        // RGB'yi HSL'ye Ã§evir
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return { h: h * 360, s: s, l: l };
        }

        // Rengi SÃœREKLI VÄ°BRANT tut
        function makeVibrant(color) {
            const hsl = rgbToHsl(color.r, color.g, color.b);
            
            // Saturation'Ä± maksimuma Ã§ek (0.9+)
            hsl.s = Math.max(0.85, hsl.s);
            
            // Lightness'Ä± ideal aralÄ±ÄŸa getir (0.45-0.55)
            if (hsl.l < 0.45) hsl.l = 0.45;
            if (hsl.l > 0.55) hsl.l = 0.55;
            
            // HSL'yi tekrar RGB'ye Ã§evir
            return hslToRgb(hsl.h, hsl.s, hsl.l);
        }

        // HSL'yi RGB'ye Ã§evir
        function hslToRgb(h, s, l) {
            h /= 360;
            
            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        // ðŸŒŠ HAREKET PATTERNLERÄ°
        const FLOW_PATTERNS = [
            { type: 'circle', radius: 160, clockwise: true },
            { type: 'circle', radius: 160, clockwise: false },
            { type: 'circle', radius: 130, clockwise: true },
            { type: 'spiral', startRadius: 50, endRadius: 150, clockwise: true },
            { type: 'spiral', startRadius: 150, endRadius: 50, clockwise: false },
            { type: 's_curve', amplitude: 90, length: 320 },
            { type: 'wave', amplitude: 80, wavelength: 220, length: 360 }
        ];

        // ðŸŽ¹ PÄ°YANO MESAJ SÄ°STEMÄ°
        window.addEventListener('message', (event) => {
            if (event.data.type === 'pianoKeyPress') {
                const colors = event.data.colors || [];
                const key = event.data.key;
                
                if (colors.length === 0) return;
                
                const bestColors = selectBestColors(colors);
                if (bestColors.length === 0) return;
                
                console.log(`ðŸŽ¹ ${key.toUpperCase()} â†’ ${bestColors.length} dominant colors`);
                
                const pattern = FLOW_PATTERNS[Math.floor(Math.random() * FLOW_PATTERNS.length)];
                
                const startX = Math.random() * 0.3 * parentWidth + 0.35 * parentWidth;
                const startY = Math.random() * 0.3 * parentHeight + 0.35 * parentHeight;
                
                createFluidFlow(startX, startY, bestColors, pattern);
            }
        });

        function setPianoColor(color) {
            if (typeof CABLES === 'undefined' || !CABLES.patch) return;
            
            try {
                // Rengi VIBRANT tut
                const vibrantColor = makeVibrant(color);
                
                const normalizedColor = [
                    vibrantColor.r / 255,
                    vibrantColor.g / 255,
                    vibrantColor.b / 255
                ];
                CABLES.patch.setVariable('SplatColor', normalizedColor);
            } catch(e) {}
        }

        // ðŸŽ¨ RENK BLENDING - VÄ°BRANT KAL
        function blendColors(color1, color2, ratio) {
            const blended = {
                r: Math.round(color1.r * (1 - ratio) + color2.r * ratio),
                g: Math.round(color1.g * (1 - ratio) + color2.g * ratio),
                b: Math.round(color1.b * (1 - ratio) + color2.b * ratio)
            };
            
            // Blend edilmiÅŸ rengi de vibrant yap
            return makeVibrant(blended);
        }

        // ðŸŒŠ FLUID AKIÅžI - YUMUÅžAK BAÅžLANGIÃ‡
        function createFluidFlow(startX, startY, colors, pattern) {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth;
            const height = parentHeight || window.innerHeight;
            
            // SABÄ°T SÃœRE: 200 frame Ã— 18ms = 3.6 saniye
            const TOTAL_FRAMES = 200;
            const FRAME_DURATION = 18;
            
            let frameIndex = 0;
            
            // Path hesapla
            const basePath = generateBasePath(startX, startY, pattern, width, height, TOTAL_FRAMES);
            
            // Ä°lk rengi set et
            setPianoColor(colors[0]);
            
            // Ã‡Ã–ZÃœM: Ä°lk mousedown'Ä± path'in daha ilerisinde yap
            // Ä°lk %20'sini atla - bÃ¶ylece patlama olmaz
            const startFrame = Math.floor(basePath.length * 0.2);
            let currentX = basePath[startFrame].x;
            let currentY = basePath[startFrame].y;
            
            console.log(`ðŸŽ¨ Fluid baÅŸlÄ±yor: frame ${startFrame}/${TOTAL_FRAMES}, ${colors.length} renk`);
            
            // MOUSEDOWN - ama uzak bir noktadan
            canvas.dispatchEvent(new MouseEvent('mousedown', {
                clientX: currentX,
                clientY: currentY,
                button: 0,
                buttons: 1,
                bubbles: true
            }));
            
            // Hemen hareket baÅŸlat - ama yumuÅŸak
            setTimeout(() => {
                // ANA ANÄ°MASYON
                const animationInterval = setInterval(() => {
                    frameIndex++;
                    
                    if (frameIndex >= TOTAL_FRAMES - startFrame) {
                        clearInterval(animationInterval);
                        
                        // MOUSEUP
                        canvas.dispatchEvent(new MouseEvent('mouseup', {
                            clientX: currentX,
                            clientY: currentY,
                            button: 0,
                            buttons: 0,
                            bubbles: true
                        }));
                        
                        console.log('âœ… Fluid tamamlandÄ±');
                        return;
                    }
                    
                    const actualFrame = frameIndex + startFrame;
                    
                    // RENK BLENDING - smooth ve vibrant
                    const progress = frameIndex / (TOTAL_FRAMES - startFrame);
                    const colorProgress = progress * (colors.length - 1);
                    const colorIndex = Math.floor(colorProgress);
                    const colorBlend = colorProgress - colorIndex;
                    
                    if (colorIndex < colors.length - 1) {
                        const blendedColor = blendColors(
                            colors[colorIndex], 
                            colors[colorIndex + 1], 
                            colorBlend
                        );
                        setPianoColor(blendedColor);
                    } else {
                        setPianoColor(colors[colors.length - 1]);
                    }
                    
                    // YENÄ° POZÄ°SYON
                    if (actualFrame < basePath.length) {
                        currentX = basePath[actualFrame].x;
                        currentY = basePath[actualFrame].y;
                        
                        currentX = Math.max(20, Math.min(width - 20, currentX));
                        currentY = Math.max(20, Math.min(height - 20, currentY));
                        
                        // MOUSEMOVE
                        canvas.dispatchEvent(new MouseEvent('mousemove', {
                            clientX: currentX,
                            clientY: currentY,
                            button: 0,
                            buttons: 1,
                            bubbles: true
                        }));
                    }
                    
                }, FRAME_DURATION);
            }, 40); // Daha kÄ±sa bekleme - ama yeterli smooth baÅŸlangÄ±Ã§ iÃ§in
        }

        // ðŸŽ¨ PATH GENERATOR
        function generateBasePath(startX, startY, pattern, width, height, pointCount) {
            const points = [];
            
            const noiseOffsetX = Math.random() * 1000;
            const noiseOffsetY = Math.random() * 1000;
            
            for (let i = 0; i < pointCount; i++) {
                const t = i / pointCount;
                let x, y;
                
                const noiseScale = 0.025;
                const noiseX = (Math.sin(i * noiseScale + noiseOffsetX) + 
                               Math.sin(i * noiseScale * 2.3 + noiseOffsetX * 1.4)) * 10;
                const noiseY = (Math.cos(i * noiseScale + noiseOffsetY) + 
                               Math.cos(i * noiseScale * 1.9 + noiseOffsetY * 1.7)) * 10;
                
                switch(pattern.type) {
                    case 'circle':
                        const angleCircle = t * Math.PI * 2 * (pattern.clockwise ? 1 : -1);
                        const breathe = 1 + Math.sin(t * Math.PI * 2.5) * 0.1;
                        x = startX + Math.cos(angleCircle) * pattern.radius * breathe + noiseX;
                        y = startY + Math.sin(angleCircle) * pattern.radius * breathe + noiseY;
                        break;
                        
                    case 'spiral':
                        const angleSpiral = t * Math.PI * 4 * (pattern.clockwise ? 1 : -1);
                        const radiusSpiral = pattern.startRadius + 
                                            (pattern.endRadius - pattern.startRadius) * t;
                        x = startX + Math.cos(angleSpiral) * radiusSpiral + noiseX;
                        y = startY + Math.sin(angleSpiral) * radiusSpiral + noiseY;
                        break;
                        
                    case 's_curve':
                        x = startX + (t - 0.5) * pattern.length + noiseX;
                        y = startY + Math.sin(t * Math.PI * 2) * pattern.amplitude + noiseY;
                        break;
                        
                    case 'wave':
                        const waveProgress = t * pattern.length;
                        x = startX + waveProgress * Math.cos(Math.PI / 6) + noiseX;
                        y = startY + waveProgress * Math.sin(Math.PI / 6) + 
                            Math.sin(waveProgress / pattern.wavelength * Math.PI * 2) * pattern.amplitude + noiseY;
                        break;
                        
                    default:
                        x = startX + t * 100;
                        y = startY + t * 100;
                }
                
                points.push({ x, y });
            }
            
            return points;
        }

        window.addEventListener('DOMContentLoaded', () => {
            forceFullScreenCanvas();
        });

        document.addEventListener("CABLES.jsLoaded", function (event) {
            forceFullScreenCanvas();
            
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "js/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true }
            });
            
            hideStatsPanels();
            setTimeout(forceFullScreenCanvas, 50);
        });

        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
        
        setInterval(hideStatsPanels, 1000);
        setInterval(forceFullScreenCanvas, 2000);
        
        window.addEventListener('resize', () => {
            try {
                if (window.parent !== window) {
                    parentWidth = window.parent.innerWidth;
                    parentHeight = window.parent.innerHeight;
                }
            } catch(e) {
                parentWidth = window.innerWidth;
                parentHeight = window.innerHeight;
            }
            forceFullScreenCanvas();
        });

        window.addEventListener('message', (event) => {
            if (event.data.type === 'parentResize') {
                parentWidth = event.data.width;
                parentHeight = event.data.height;
                forceFullScreenCanvas();
            }
        });
    </script>
</body>
</html>
