<!DOCTYPE html>
<html lang="en">
<head>
    <title>Piano Fluid - Living Art</title>
    <style>
        * {
            margin: 0 !important;
            padding: 0 !important;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            box-sizing: border-box !important;
        }

        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent !important;
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            position: relative;
        }

        #glcanvas {
            display: block !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            outline: 0 !important;
            transform: none !important;
            background: transparent !important;
        }

        div[style*="position: absolute"],
        div[style*="fixed"],
        .cables-stats,
        .stats-panel {
            display: none !important;
            visibility: hidden !important;
        }
    </style>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
</head>
<body>
    <canvas id="glcanvas" tabindex="1"></canvas>
    <script type="text/javascript" src="js/patch.js" async></script>
    <script type="text/javascript">

        function showError(initiator,...args) {}

        let parentWidth = window.innerWidth;
        let parentHeight = window.innerHeight;

        if (window.parent !== window) {
            try {
                parentWidth = window.parent.innerWidth;
                parentHeight = window.parent.innerHeight;
            } catch(e) {}
        }

        function forceFullScreenCanvas() {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth || document.documentElement.clientWidth;
            const height = parentHeight || window.innerHeight || document.documentElement.clientHeight;
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
        }

        function patchInitialized(patch) {
            console.log('âœ… Fluid hazÄ±r!');
            hideStatsPanels();
            forceFullScreenCanvas();
            
            setTimeout(forceFullScreenCanvas, 100);
            setTimeout(forceFullScreenCanvas, 500);
            setTimeout(forceFullScreenCanvas, 1000);
            setTimeout(forceFullScreenCanvas, 2000);
        }

        function patchFinishedLoading(patch) {
            console.log('ðŸŽ¨ YÃ¼kleme tamamlandÄ±!');
            hideStatsPanels();
            forceFullScreenCanvas();
        }

        function hideStatsPanels() {
            setTimeout(() => {
                const statsDivs = document.querySelectorAll('div');
                statsDivs.forEach(div => {
                    const style = div.getAttribute('style');
                    if (style && (style.includes('position: absolute') || style.includes('position: fixed'))) {
                        div.style.display = 'none';
                        div.style.visibility = 'hidden';
                    }
                });
            }, 100);
        }

        function selectBestColors(colors) {
            if (!colors || colors.length === 0) {
                return [
                    {r: 255, g: 100, b: 200},
                    {r: 100, g: 200, b: 255},
                    {r: 255, g: 200, b: 100}
                ];
            }

            const vibrantColors = colors.filter(c => {
                const brightness = (c.r + c.g + c.b) / 3;
                const saturation = Math.max(c.r, c.g, c.b) - Math.min(c.r, c.g, c.b);
                return brightness > 50 && brightness < 220 && saturation > 40;
            });

            const workingColors = vibrantColors.length > 0 ? vibrantColors : colors;

            const sortedByVibrance = [...workingColors].sort((a, b) => {
                const satA = Math.max(a.r, a.g, a.b) - Math.min(a.r, a.g, a.b);
                const satB = Math.max(b.r, b.g, b.b) - Math.min(b.r, b.g, b.b);
                return satB - satA;
            });

            return sortedByVibrance.slice(0, 8);
        }

        // ðŸŒŠ BASÄ°T AMA ETKÄ°LÄ° HAREKET PATTERNLERÄ°
        const FLOW_PATTERNS = [
            { type: 'circle', radius: 180, clockwise: true },
            { type: 'circle', radius: 180, clockwise: false },
            { type: 'circle', radius: 140, clockwise: true },
            { type: 'circle', radius: 140, clockwise: false },
            { type: 'spiral', startRadius: 40, endRadius: 160, clockwise: true },
            { type: 'spiral', startRadius: 160, endRadius: 40, clockwise: false },
            { type: 's_curve', amplitude: 100, length: 350 },
            { type: 'wave', amplitude: 90, wavelength: 250, length: 400 }
        ];

        // ðŸŽ¹ PÄ°YANO MESAJ SÄ°STEMÄ°
        window.addEventListener('message', (event) => {
            if (event.data.type === 'pianoKeyPress') {
                const colors = event.data.colors || [];
                const key = event.data.key;
                
                if (colors.length === 0) return;
                
                const bestColors = selectBestColors(colors);
                if (bestColors.length === 0) return;
                
                // 1-2 fluid
                const numFluids = Math.random() > 0.6 ? 2 : 1;
                
                console.log(`ðŸŽ¹ ${key.toUpperCase()} â†’ ${numFluids} fluid (${bestColors.length} colors)`);
                
                for (let i = 0; i < numFluids; i++) {
                    const pattern = FLOW_PATTERNS[Math.floor(Math.random() * FLOW_PATTERNS.length)];
                    
                    const startX = Math.random() * 0.3 * parentWidth + 0.35 * parentWidth;
                    const startY = Math.random() * 0.3 * parentHeight + 0.35 * parentHeight;
                    
                    setTimeout(() => {
                        createFluidFlow(startX, startY, bestColors, pattern);
                    }, i * 180);
                }
            }
        });

        function setPianoColor(color) {
            if (typeof CABLES === 'undefined' || !CABLES.patch) return;
            
            try {
                const normalizedColor = [
                    color.r / 255,
                    color.g / 255,
                    color.b / 255
                ];
                CABLES.patch.setVariable('SplatColor', normalizedColor);
            } catch(e) {}
        }

        // ðŸŽ¨ Ä°KÄ° RENGÄ° BLEND ET
        function blendColors(color1, color2, ratio) {
            return {
                r: Math.round(color1.r * (1 - ratio) + color2.r * ratio),
                g: Math.round(color1.g * (1 - ratio) + color2.g * ratio),
                b: Math.round(color1.b * (1 - ratio) + color2.b * ratio)
            };
        }

        // ðŸŒŠ FLUID AKIÅžI - 3-4 SANÄ°YE, SMOOTH BAÅžLANGIÃ‡, RENK KARIÅžIMI
        function createFluidFlow(startX, startY, colors, pattern) {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth;
            const height = parentHeight || window.innerHeight;
            
            // Path'i Ã¶nceden hesapla - 180 nokta = 3 saniye (180 * 16ms)
            const pathPoints = generateSmoothPath(startX, startY, pattern, width, height, 180);
            
            let pointIndex = 0;
            const totalPoints = pathPoints.length;
            
            // Ä°lk rengi set et
            setPianoColor(colors[0]);
            
            // Ä°LK NOKTA - BAÅžLANGIÃ‡ POZÄ°SYONU (patlamayÄ± Ã¶nlemek iÃ§in)
            // Path'in biraz ilerisinden baÅŸla
            let currentX = pathPoints[Math.min(5, pathPoints.length - 1)].x;
            let currentY = pathPoints[Math.min(5, pathPoints.length - 1)].y;
            
            // MOUSEDOWN - Fluid injection
            canvas.dispatchEvent(new MouseEvent('mousedown', {
                clientX: currentX,
                clientY: currentY,
                button: 0,
                buttons: 1,
                bubbles: true
            }));
            
            // Ä°lk hareketi biraz bekleyerek baÅŸlat
            setTimeout(() => {
                // MOUSEMOVE ANÄ°MASYONU
                const moveInterval = setInterval(() => {
                    pointIndex++;
                    
                    if (pointIndex >= totalPoints) {
                        clearInterval(moveInterval);
                        
                        // MOUSEUP - SÄ±vÄ±yÄ± serbest bÄ±rak
                        canvas.dispatchEvent(new MouseEvent('mouseup', {
                            clientX: currentX,
                            clientY: currentY,
                            button: 0,
                            buttons: 0,
                            bubbles: true
                        }));
                        
                        console.log('ðŸŽ¨ Fluid tamamlandÄ±');
                        return;
                    }
                    
                    // RENK BLENDING - TÃ¼m renkler smooth geÃ§iÅŸlerle karÄ±ÅŸÄ±yor
                    const progress = pointIndex / totalPoints;
                    const colorProgress = progress * (colors.length - 1);
                    const colorIndex = Math.floor(colorProgress);
                    const colorBlend = colorProgress - colorIndex;
                    
                    if (colorIndex < colors.length - 1) {
                        const blendedColor = blendColors(
                            colors[colorIndex], 
                            colors[colorIndex + 1], 
                            colorBlend
                        );
                        setPianoColor(blendedColor);
                    } else {
                        setPianoColor(colors[colors.length - 1]);
                    }
                    
                    currentX = pathPoints[pointIndex].x;
                    currentY = pathPoints[pointIndex].y;
                    
                    // SÄ±nÄ±r kontrolÃ¼
                    currentX = Math.max(10, Math.min(width - 10, currentX));
                    currentY = Math.max(10, Math.min(height - 10, currentY));
                    
                    // MOUSEMOVE - Kuvvet vektÃ¶rÃ¼ + boya enjeksiyonu
                    canvas.dispatchEvent(new MouseEvent('mousemove', {
                        clientX: currentX,
                        clientY: currentY,
                        button: 0,
                        buttons: 1,
                        bubbles: true
                    }));
                    
                }, 16); // 60fps
            }, 50); // Smooth baÅŸlangÄ±Ã§ iÃ§in 50ms gecikme
        }

        // ðŸŽ¨ SMOOTH PATH GENERATOR
        function generateSmoothPath(startX, startY, pattern, width, height, pointCount) {
            const points = [];
            
            // Perlin-like noise
            const noiseOffsetX = Math.random() * 1000;
            const noiseOffsetY = Math.random() * 1000;
            
            for (let i = 0; i < pointCount; i++) {
                const t = i / pointCount;
                let x, y;
                
                // Organic noise - daha hafif
                const noiseScale = 0.02;
                const noiseX = (Math.sin(i * noiseScale + noiseOffsetX) + 
                               Math.sin(i * noiseScale * 2.1 + noiseOffsetX * 1.3)) * 12;
                const noiseY = (Math.cos(i * noiseScale + noiseOffsetY) + 
                               Math.cos(i * noiseScale * 1.7 + noiseOffsetY * 1.8)) * 12;
                
                switch(pattern.type) {
                    case 'circle':
                        const angleCircle = t * Math.PI * 2 * (pattern.clockwise ? 1 : -1);
                        const breathe = 1 + Math.sin(t * Math.PI * 3) * 0.12;
                        x = startX + Math.cos(angleCircle) * pattern.radius * breathe + noiseX;
                        y = startY + Math.sin(angleCircle) * pattern.radius * breathe + noiseY;
                        break;
                        
                    case 'spiral':
                        const angleSpiral = t * Math.PI * 5 * (pattern.clockwise ? 1 : -1);
                        const radiusSpiral = pattern.startRadius + 
                                            (pattern.endRadius - pattern.startRadius) * t;
                        x = startX + Math.cos(angleSpiral) * radiusSpiral + noiseX;
                        y = startY + Math.sin(angleSpiral) * radiusSpiral + noiseY;
                        break;
                        
                    case 's_curve':
                        x = startX + (t - 0.5) * pattern.length + noiseX;
                        y = startY + Math.sin(t * Math.PI * 2) * pattern.amplitude + noiseY;
                        break;
                        
                    case 'wave':
                        const waveProgress = t * pattern.length;
                        x = startX + waveProgress * Math.cos(Math.PI / 6) + noiseX;
                        y = startY + waveProgress * Math.sin(Math.PI / 6) + 
                            Math.sin(waveProgress / pattern.wavelength * Math.PI * 2) * pattern.amplitude + noiseY;
                        break;
                        
                    default:
                        x = startX;
                        y = startY;
                }
                
                points.push({ x, y });
            }
            
            // Catmull-Rom spline
            return smoothPathWithSpline(points);
        }

        // ðŸŒ€ CATMULL-ROM SPLINE
        function smoothPathWithSpline(points) {
            if (points.length < 4) return points;
            
            const smoothPoints = [];
            const tension = 0.5;
            
            for (let i = 0; i < points.length - 3; i++) {
                const p0 = points[i];
                const p1 = points[i + 1];
                const p2 = points[i + 2];
                const p3 = points[i + 3];
                
                // Her segment iÃ§in 6 interpolation (daha az yoÄŸun)
                const steps = 6;
                for (let t = 0; t < steps; t++) {
                    const tNorm = t / steps;
                    const tt = tNorm * tNorm;
                    const ttt = tt * tNorm;
                    
                    const q0 = -tension * ttt + 2 * tension * tt - tension * tNorm;
                    const q1 = (2 - tension) * ttt + (tension - 3) * tt + 1;
                    const q2 = (tension - 2) * ttt + (3 - 2 * tension) * tt + tension * tNorm;
                    const q3 = tension * ttt - tension * tt;
                    
                    const x = p0.x * q0 + p1.x * q1 + p2.x * q2 + p3.x * q3;
                    const y = p0.y * q0 + p1.y * q1 + p2.y * q2 + p3.y * q3;
                    
                    smoothPoints.push({ x, y });
                }
            }
            
            return smoothPoints;
        }

        window.addEventListener('DOMContentLoaded', () => {
            forceFullScreenCanvas();
        });

        document.addEventListener("CABLES.jsLoaded", function (event) {
            forceFullScreenCanvas();
            
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "js/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true }
            });
            
            hideStatsPanels();
            setTimeout(forceFullScreenCanvas, 50);
        });

        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
        
        setInterval(hideStatsPanels, 1000);
        setInterval(forceFullScreenCanvas, 2000);
        
        window.addEventListener('resize', () => {
            try {
                if (window.parent !== window) {
                    parentWidth = window.parent.innerWidth;
                    parentHeight = window.parent.innerHeight;
                }
            } catch(e) {
                parentWidth = window.innerWidth;
                parentHeight = window.innerHeight;
            }
            forceFullScreenCanvas();
        });

        window.addEventListener('message', (event) => {
            if (event.data.type === 'parentResize') {
                parentWidth = event.data.width;
                parentHeight = event.data.height;
                forceFullScreenCanvas();
            }
        });
    </script>
</body>
</html>
