<!DOCTYPE html>
<html lang="en">
<head>
    <title>Fluid from bodyHands</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            background-color: transparent !important; /* ŞEFFAF - iframe'de görünsün */
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            overflow: hidden;
            position: fixed;
        }

        #glcanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            outline: 0;
            background: transparent !important; /* ŞEFFAF */
        }

        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* TÜM overlay, text, settings ve debug yazılarını GİZLE */
        .cables-info,
        .cables-fps,
        .cables-debug,
        .cables-settings,
        div[style*="position: absolute"],
        div[style*="position: fixed"],
        div[style*="z-index"],
        div[class*="cables"],
        div[id*="cables"],
        div[class*="settings"],
        div[id*="settings"],
        span, p, h1, h2, h3, h4, h5, h6,
        div:not(#root):not(body) {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

    </style>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
    <meta itemprop="name" content="Fluid from bodyHands">
    <meta itemprop="description" content="made with cables">
    <meta itemprop="image" content="screenshot.png">
    <meta name="description" content="made with cables"/>

</head>
<body>
    <canvas id="glcanvas" tabindex="1"></canvas>

    
    <script type="text/javascript" src="js/patch.js" async></script>
    

    <script type="text/javascript">

        function showError(initiator,...args)
        {
            // Error mesajlarını da console'a yazma
            // CABLES.logErrorConsole("[" + initiator + "]", ...args);
        }

        // Canvas boyutlandırma fonksiyonu
        function resizeCanvas() {
            const canvas = document.getElementById('glcanvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.width = '100vw';
            canvas.style.height = '100vh';
        }

        // ZORLA TAM EKRAN - Cables override
        function forceCanvasResize() {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            canvas.width = w;
            canvas.height = h;
            canvas.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: ${w}px !important;
                height: ${h}px !important;
                display: block !important;
            `;
            
            // Cables'e resize event gönder
            if (CABLES && CABLES.patch) {
                window.dispatchEvent(new Event('resize'));
            }
            
            console.log('🎯 FORCED resize:', w, 'x', h);
        }

        // MESAJ ALICI SİSTEM - Piyanodan renk mesajları al
        window.addEventListener('message', (event) => {
            if (event.data.type === 'pianoKeyPress') {
                const colors = event.data.colors;
                const key = event.data.key;
                const x = event.data.x || Math.random() * window.innerWidth;
                const y = event.data.y || Math.random() * window.innerHeight;
                
                console.log('📨 Piyanodan mesaj:', key, colors.length, 'renk');
                console.log('🎨 Gelen renkler:', colors.slice(0, 5).map(c => `rgb(${c.r},${c.g},${c.b})`));
                
                triggerFluidWithColors(colors, x, y);
            }
        });

        // Renkleri fluid'e uygula ve efekti tetikle
        // Renkleri fluid'e uygula ve efekti tetikle - GELİŞMİŞ SİSTEM
        let currentColorOps = null;
        
        function triggerFluidWithColors(colors, x, y) {
            if (!colors || colors.length === 0) {
                colors = [{ r: 255, g: 100, b: 200 }];
            }
            
            console.log('🎨 Fluid tetikleniyor:', colors.length, 'renk');
            console.log('🌈 İlk 3 renk:', colors.slice(0, 3).map(c => 
                `rgb(${c.r},${c.g},${c.b})`
            ).join(' | '));
            
            // 🔥 CABLES OPS'LARINI DEĞİŞTİR
            if (CABLES && CABLES.patch && CABLES.patch.ops) {
                // Renk operatörünü bul ve değiştir
                CABLES.patch.ops.forEach(op => {
                    if (op.portsIn) {
                        op.portsIn.forEach(port => {
                            // R, G, B portlarını bul
                            if (port.name === 'r' || port.name === 'R' || port.name === 'red') {
                                const color = colors[0];
                                port.set(color.r / 255);
                                console.log('🔴 R değişti:', color.r);
                            }
                            if (port.name === 'g' || port.name === 'G' || port.name === 'green') {
                                const color = colors[0];
                                port.set(color.g / 255);
                                console.log('🟢 G değişti:', color.g);
                            }
                            if (port.name === 'b' || port.name === 'B' || port.name === 'blue') {
                                const color = colors[0];
                                port.set(color.b / 255);
                                console.log('🔵 B değişti:', color.b);
                            }
                        });
                    }
                });
            }
            
            // HER RENKTEN BİR EFEKT OLUŞTUR (max 5 renk)
            const colorsToUse = colors.slice(0, 5);
            
            colorsToUse.forEach((color, index) => {
                setTimeout(() => {
                    const startAngle = (index / colorsToUse.length) * Math.PI * 2;
                    const offsetX = Math.cos(startAngle) * 50;
                    const offsetY = Math.sin(startAngle) * 50;
                    const startX = x + offsetX;
                    const startY = y + offsetY;
                    
                    createColorfulSpiral(startX, startY, color, index);
                }, index * 50);
            });
        }

        // Renkli spiral efekt oluştur
        function createColorfulSpiral(x, y, color, index) {
            simulateMouseDown(x, y);
            
            let angle = index * 1.2; // Her spiral farklı açıda başlar
            let radius = 0;
            let moveCount = 0;
            const maxMoves = 25 + Math.random() * 10;
            
            const spiralInterval = setInterval(() => {
                angle += 0.4 + (index * 0.1); // Her spiral farklı hızda döner
                radius += 2.5 + Math.random();
                
                const newX = x + Math.cos(angle) * radius;
                const newY = y + Math.sin(angle) * radius;
                
                simulateMouseMove(newX, newY);
                moveCount++;
                
                if (moveCount > maxMoves || radius > 250) {
                    clearInterval(spiralInterval);
                    simulateMouseUp(newX, newY);
                }
            }, 16);
        }

        // Sayfa yüklendiğinde ve boyut değiştiğinde canvas'ı ayarla
        window.addEventListener('load', () => {
            resizeCanvas();
            setTimeout(resizeCanvas, 100);
            setTimeout(resizeCanvas, 500);
            setTimeout(resizeCanvas, 1000);
        });
        window.addEventListener('resize', resizeCanvas);
        
        // iframe'de yüklendiğinde de resize
        if (window.parent !== window) {
            setTimeout(resizeCanvas, 100);
            setTimeout(resizeCanvas, 500);
        }

        // Otomatik mouse hareketi için değişkenler
        let autoMoveActive = false;
        let autoMoveInterval = null;
        let lastMouseX = window.innerWidth / 2;
        let lastMouseY = window.innerHeight / 2;
        let mouseVelocityX = (Math.random() - 0.5) * 10;
        let mouseVelocityY = (Math.random() - 0.5) * 10;

        function simulateMouseMove(x, y) {
            const canvas = document.getElementById('glcanvas');
            const event = new MouseEvent('mousemove', {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX: x,
                clientY: y
            });
            canvas.dispatchEvent(event);
        }

        function simulateMouseDown(x, y) {
            const canvas = document.getElementById('glcanvas');
            const event = new MouseEvent('mousedown', {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX: x,
                clientY: y,
                button: 0
            });
            canvas.dispatchEvent(event);
        }

        function simulateMouseUp(x, y) {
            const canvas = document.getElementById('glcanvas');
            const event = new MouseEvent('mouseup', {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX: x,
                clientY: y,
                button: 0
            });
            canvas.dispatchEvent(event);
        }

        function startAutoMove() {
            if (autoMoveInterval) return;
            
            autoMoveActive = true;
            autoMoveInterval = setInterval(() => {
                // Yumuşak, organik hareket
                mouseVelocityX += (Math.random() - 0.5) * 2;
                mouseVelocityY += (Math.random() - 0.5) * 2;
                
                // Hız limitleyici
                mouseVelocityX = Math.max(-8, Math.min(8, mouseVelocityX));
                mouseVelocityY = Math.max(-8, Math.min(8, mouseVelocityY));
                
                lastMouseX += mouseVelocityX;
                lastMouseY += mouseVelocityY;
                
                // Sınırları kontrol et ve sekme efekti
                if (lastMouseX <= 0 || lastMouseX >= window.innerWidth) {
                    mouseVelocityX *= -0.8;
                    lastMouseX = Math.max(0, Math.min(window.innerWidth, lastMouseX));
                }
                if (lastMouseY <= 0 || lastMouseY >= window.innerHeight) {
                    mouseVelocityY *= -0.8;
                    lastMouseY = Math.max(0, Math.min(window.innerHeight, lastMouseY));
                }
                
                simulateMouseMove(lastMouseX, lastMouseY);
            }, 16); // ~60 FPS
        }

        // TÜM overlay elementlerini sürekli temizle
        function hideAllOverlays() {
            const allElements = document.querySelectorAll('div, span, p, h1, h2, h3, h4, h5, h6');
            allElements.forEach(elem => {
                if (elem.id !== 'glcanvas' && elem.tagName.toLowerCase() !== 'canvas') {
                    elem.style.display = 'none';
                    elem.style.visibility = 'hidden';
                    elem.style.opacity = '0';
                    elem.style.pointerEvents = 'none';
                }
            });
        }

        function patchInitialized(patch)
        {
            resizeCanvas();
            
            // Patch yüklendiğinde otomatik hareketi başlat
            setTimeout(() => {
                startAutoMove();
            }, 1000);

            // AGRESIF RESIZE - Cables yüklendikten sonra
            setTimeout(() => forceCanvasResize(), 100);
            setTimeout(() => forceCanvasResize(), 500);
            setTimeout(() => forceCanvasResize(), 1000);
            setTimeout(() => forceCanvasResize(), 2000);

            // Tüm overlay elementlerini gizle
            setTimeout(hideAllOverlays, 100);
            setTimeout(hideAllOverlays, 500);
            setTimeout(hideAllOverlays, 1000);
            setTimeout(hideAllOverlays, 2000);
        }

        function forceCanvasResize() {
            const canvas = document.getElementById('glcanvas');
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            // Canvas element boyutu
            canvas.width = w;
            canvas.height = h;
            
            // CSS boyutu
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            canvas.style.position = 'absolute';
            canvas.style.top = '0px';
            canvas.style.left = '0px';
            
            // Cables patch'i de resize et
            if (CABLES.patch && CABLES.patch.cgl) {
                CABLES.patch.cgl.setSize(w, h);
            }
            
            console.log('🖼️ Canvas FORCED resize:', w, 'x', h);
        }

        function patchFinishedLoading(patch)
        {
            resizeCanvas();
            hideAllOverlays();
            
            // Yükleme bittiğinde de overlay kontrolü yap - sürekli izle
            const observer = new MutationObserver(() => {
                hideAllOverlays();
            });
            observer.observe(document.body, { 
                childList: true, 
                subtree: true,
                attributes: true,
                characterData: true
            });

            // Her 100ms'de bir kontrol et
            setInterval(hideAllOverlays, 100);
            
            // 🎨 CABLES PATCH'İNE ERİŞ - Renk kontrolü için
            console.log('🔧 Cables patch yüklendi, ops sayısı:', patch.ops.length);
            
            // Tüm ops'ları tara, renk ile ilgili olanları bul
            window.CABLES_OPS = patch.ops;
            patch.ops.forEach((op, index) => {
                // Color, RGB veya Paint içeren operatörleri logla
                if (op.objName && (
                    op.objName.toLowerCase().includes('color') ||
                    op.objName.toLowerCase().includes('rgb') ||
                    op.objName.toLowerCase().includes('paint')
                )) {
                    console.log(`🎨 Op ${index}: ${op.objName}`, op);
                }
            });
        }

        // D tuşunu ve diğer ayar tuşlarını engelle
        // İzin verilen tuşlar listesi
        const allowedKeys = ['z', 'x', 'c', 'v', 'b', 'n', 'm', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'];
        
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            
            // Eğer izin verilen tuşlardan değilse, engelle
            if (!allowedKeys.includes(key)) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }

            // İzin verilen tuşlara basıldığında fluid efekti
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight;
            
            simulateMouseDown(x, y);
            
            // Kısa bir süre boyunca etrafında hareket et
            let moveCount = 0;
            const moveInterval = setInterval(() => {
                const angle = (moveCount / 10) * Math.PI * 2;
                const radius = 50 + moveCount * 3;
                const newX = x + Math.cos(angle) * radius;
                const newY = y + Math.sin(angle) * radius;
                
                simulateMouseMove(newX, newY);
                moveCount++;
                
                if (moveCount > 15) {
                    clearInterval(moveInterval);
                    simulateMouseUp(newX, newY);
                }
            }, 16);
        }, true); // true = capture phase, en önce yakala

        // Keyup eventi de engelle
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (!allowedKeys.includes(key)) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }
        }, true);

        // Keypress eventi de engelle
        document.addEventListener('keypress', (e) => {
            const key = e.key.toLowerCase();
            if (!allowedKeys.includes(key)) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }
        }, true);

        document.addEventListener("CABLES.jsLoaded", function (event)
        {
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "js/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true }
            });
        });

        // Ekrana tıklandığında otomatik hareket toggle
        document.getElementById('glcanvas').addEventListener('click', (e) => {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            if (!autoMoveActive) {
                startAutoMove();
            } else {
                // Tıklanan noktadan spiral hareket
                const startX = e.clientX;
                const startY = e.clientY;
                let angle = 0;
                let radius = 0;
                
                simulateMouseDown(startX, startY);
                
                const spiralInterval = setInterval(() => {
                    angle += 0.3;
                    radius += 2;
                    const x = startX + Math.cos(angle) * radius;
                    const y = startY + Math.sin(angle) * radius;
                    
                    simulateMouseMove(x, y);
                    
                    if (radius > 150) {
                        clearInterval(spiralInterval);
                        simulateMouseUp(x, y);
                    }
                }, 16);
            }
        });

        // disable rubberband effect on mobile devices
        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);

        // Sayfa yüklendiğinde hemen overlay temizliği başlat
        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            setInterval(hideAllOverlays, 100);
        });
    </script>
</body>
</html>
