<!DOCTYPE html>
<html lang="en">
<head>
    <title>Piano Fluid - Living Art</title>
    <style>
        * {
            margin: 0 !important;
            padding: 0 !important;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            box-sizing: border-box !important;
        }

        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent !important;
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            position: relative;
        }

        #glcanvas {
            display: block !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            outline: 0 !important;
            transform: none !important;
            background: transparent !important;
        }

        div[style*="position: absolute"],
        div[style*="fixed"],
        .cables-stats,
        .stats-panel {
            display: none !important;
            visibility: hidden !important;
        }
    </style>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">
</head>
<body>
    <canvas id="glcanvas" tabindex="1"></canvas>
    <script type="text/javascript" src="js/patch.js" async></script>
    <script type="text/javascript">

        function showError(initiator,...args) {}

        let parentWidth = window.innerWidth;
        let parentHeight = window.innerHeight;

        if (window.parent !== window) {
            try {
                parentWidth = window.parent.innerWidth;
                parentHeight = window.parent.innerHeight;
            } catch(e) {}
        }

        function forceFullScreenCanvas() {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth || document.documentElement.clientWidth;
            const height = parentHeight || window.innerHeight || document.documentElement.clientHeight;
            
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
        }

        function patchInitialized(patch) {
            console.log('âœ… Fluid hazÄ±r!');
            hideStatsPanels();
            forceFullScreenCanvas();
            
            setTimeout(forceFullScreenCanvas, 100);
            setTimeout(forceFullScreenCanvas, 500);
            setTimeout(forceFullScreenCanvas, 1000);
            setTimeout(forceFullScreenCanvas, 2000);
        }

        function patchFinishedLoading(patch) {
            console.log('ðŸŽ¨ YÃ¼kleme tamamlandÄ±!');
            hideStatsPanels();
            forceFullScreenCanvas();
        }

        function hideStatsPanels() {
            setTimeout(() => {
                const statsDivs = document.querySelectorAll('div');
                statsDivs.forEach(div => {
                    const style = div.getAttribute('style');
                    if (style && (style.includes('position: absolute') || style.includes('position: fixed'))) {
                        div.style.display = 'none';
                        div.style.visibility = 'hidden';
                    }
                });
            }, 100);
        }

        function selectBestColors(colors) {
            if (!colors || colors.length === 0) {
                return [
                    {r: 255, g: 100, b: 200},
                    {r: 100, g: 200, b: 255},
                    {r: 255, g: 200, b: 100}
                ];
            }

            const vibrantColors = colors.filter(c => {
                const brightness = (c.r + c.g + c.b) / 3;
                const saturation = Math.max(c.r, c.g, c.b) - Math.min(c.r, c.g, c.b);
                return brightness > 50 && brightness < 220 && saturation > 40;
            });

            const workingColors = vibrantColors.length > 0 ? vibrantColors : colors;

            const sortedByVibrance = [...workingColors].sort((a, b) => {
                const satA = Math.max(a.r, a.g, a.b) - Math.min(a.r, a.g, a.b);
                const satB = Math.max(b.r, b.g, b.b) - Math.min(b.r, b.g, b.b);
                return satB - satA;
            });

            return sortedByVibrance.slice(0, 12);
        }

        // ðŸŒŠ BASÄ°T AMA ETKÄ°LÄ° HAREKET PATTERNLERÄ°
        const FLOW_PATTERNS = [
            // Smooth bÃ¼yÃ¼k daireler - farklÄ± yÃ¶nlerde
            { type: 'circle', radius: 200, clockwise: true },
            { type: 'circle', radius: 200, clockwise: false },
            { type: 'circle', radius: 160, clockwise: true },
            { type: 'circle', radius: 160, clockwise: false },
            
            // Spiral - iÃ§ten dÄ±ÅŸa/dÄ±ÅŸtan iÃ§e
            { type: 'spiral', startRadius: 30, endRadius: 180, clockwise: true },
            { type: 'spiral', startRadius: 180, endRadius: 30, clockwise: false },
            
            // S-curve smooth akÄ±ÅŸ
            { type: 's_curve', amplitude: 120, length: 400 },
            
            // DalgalÄ± yol
            { type: 'wave', amplitude: 100, wavelength: 300, length: 500 }
        ];

        // ðŸŽ¹ PÄ°YANO MESAJ SÄ°STEMÄ°
        window.addEventListener('message', (event) => {
            if (event.data.type === 'pianoKeyPress') {
                const colors = event.data.colors || [];
                const key = event.data.key;
                
                if (colors.length === 0) return;
                
                const bestColors = selectBestColors(colors);
                if (bestColors.length === 0) return;
                
                // 1-2 fluid oluÅŸtur
                const numFluids = Math.random() > 0.5 ? 2 : 1;
                
                console.log(`ðŸŽ¹ ${key.toUpperCase()} â†’ ${numFluids} fluid with ${bestColors.length} colors`);
                
                for (let i = 0; i < numFluids; i++) {
                    const pattern = FLOW_PATTERNS[Math.floor(Math.random() * FLOW_PATTERNS.length)];
                    
                    // Daha merkezi spawn
                    const startX = Math.random() * 0.3 * parentWidth + 0.35 * parentWidth;
                    const startY = Math.random() * 0.3 * parentHeight + 0.35 * parentHeight;
                    
                    setTimeout(() => {
                        createFluidFlow(startX, startY, bestColors, pattern);
                    }, i * 200);
                }
            }
        });

        function setPianoColor(color) {
            if (typeof CABLES === 'undefined' || !CABLES.patch) return;
            
            try {
                const normalizedColor = [
                    color.r / 255,
                    color.g / 255,
                    color.b / 255
                ];
                CABLES.patch.setVariable('SplatColor', normalizedColor);
            } catch(e) {}
        }

        // ðŸŒŠ UZUN SMOOTH FLUID AKIÅžI
        function createFluidFlow(startX, startY, colors, pattern) {
            const canvas = document.getElementById('glcanvas');
            if (!canvas) return;
            
            const width = parentWidth || window.innerWidth;
            const height = parentHeight || window.innerHeight;
            
            // Path'i Ã¶nceden hesapla
            const pathPoints = generateSmoothPath(startX, startY, pattern, width, height);
            
            let pointIndex = 0;
            let colorIndex = 0;
            
            // Her renk iÃ§in daha fazla adÄ±m
            const stepsPerColor = Math.floor(pathPoints.length / colors.length);
            let stepsSinceColorChange = 0;
            
            // Ä°lk rengi set et
            setPianoColor(colors[0]);
            
            // Ä°lk nokta
            let currentX = pathPoints[0].x;
            let currentY = pathPoints[0].y;
            
            // MOUSEDOWN - Fluid injection baÅŸlasÄ±n
            canvas.dispatchEvent(new MouseEvent('mousedown', {
                clientX: currentX,
                clientY: currentY,
                button: 0,
                buttons: 1,
                bubbles: true
            }));
            
            // UZUN MOUSEMOVE ANÄ°MASYONU
            const moveInterval = setInterval(() => {
                pointIndex++;
                stepsSinceColorChange++;
                
                if (pointIndex >= pathPoints.length) {
                    clearInterval(moveInterval);
                    
                    // MOUSEUP - SÄ±vÄ±yÄ± serbest bÄ±rak
                    canvas.dispatchEvent(new MouseEvent('mouseup', {
                        clientX: currentX,
                        clientY: currentY,
                        button: 0,
                        buttons: 0,
                        bubbles: true
                    }));
                    
                    console.log('ðŸŽ¨ Fluid tamamlandÄ± - toplam renk:', colors.length);
                    return;
                }
                
                // RENK DEÄžÄ°ÅžÄ°MÄ° - yavaÅŸ ve smooth
                if (stepsSinceColorChange >= stepsPerColor && colorIndex < colors.length - 1) {
                    colorIndex++;
                    stepsSinceColorChange = 0;
                    setPianoColor(colors[colorIndex]);
                    console.log(`  ðŸŒˆ Renk ${colorIndex + 1}/${colors.length}`);
                }
                
                currentX = pathPoints[pointIndex].x;
                currentY = pathPoints[pointIndex].y;
                
                // SÄ±nÄ±r kontrolÃ¼
                currentX = Math.max(10, Math.min(width - 10, currentX));
                currentY = Math.max(10, Math.min(height - 10, currentY));
                
                // MOUSEMOVE - Kuvvet vektÃ¶rÃ¼ + boya enjeksiyonu
                canvas.dispatchEvent(new MouseEvent('mousemove', {
                    clientX: currentX,
                    clientY: currentY,
                    button: 0,
                    buttons: 1,
                    bubbles: true
                }));
                
            }, 16); // 60fps smooth hareket
        }

        // ðŸŽ¨ SMOOTH PATH GENERATOR - Jos Stam tarzÄ± smooth curves
        function generateSmoothPath(startX, startY, pattern, width, height) {
            const points = [];
            const totalPoints = 600; // Ã‡ok uzun path - 10 saniye
            
            // Perlin-like noise iÃ§in
            const noiseOffsetX = Math.random() * 1000;
            const noiseOffsetY = Math.random() * 1000;
            
            for (let i = 0; i < totalPoints; i++) {
                const t = i / totalPoints;
                let x, y;
                
                // Organic noise ekle (Touch Designer tarzÄ±)
                const noiseScale = 0.015;
                const noiseX = (Math.sin(i * noiseScale + noiseOffsetX) + 
                               Math.sin(i * noiseScale * 2.1 + noiseOffsetX * 1.3)) * 15;
                const noiseY = (Math.cos(i * noiseScale + noiseOffsetY) + 
                               Math.cos(i * noiseScale * 1.7 + noiseOffsetY * 1.8)) * 15;
                
                switch(pattern.type) {
                    case 'circle':
                        const angleCircle = t * Math.PI * 2 * (pattern.clockwise ? 1 : -1);
                        // Breathing effect
                        const breathe = 1 + Math.sin(t * Math.PI * 4) * 0.15;
                        x = startX + Math.cos(angleCircle) * pattern.radius * breathe + noiseX;
                        y = startY + Math.sin(angleCircle) * pattern.radius * breathe + noiseY;
                        break;
                        
                    case 'spiral':
                        const angleSpiral = t * Math.PI * 6 * (pattern.clockwise ? 1 : -1);
                        const radiusSpiral = pattern.startRadius + 
                                            (pattern.endRadius - pattern.startRadius) * t;
                        x = startX + Math.cos(angleSpiral) * radiusSpiral + noiseX;
                        y = startY + Math.sin(angleSpiral) * radiusSpiral + noiseY;
                        break;
                        
                    case 's_curve':
                        x = startX + (t - 0.5) * pattern.length + noiseX;
                        y = startY + Math.sin(t * Math.PI * 2) * pattern.amplitude + noiseY;
                        break;
                        
                    case 'wave':
                        const waveProgress = t * pattern.length;
                        x = startX + waveProgress * Math.cos(Math.PI / 6) + noiseX;
                        y = startY + waveProgress * Math.sin(Math.PI / 6) + 
                            Math.sin(waveProgress / pattern.wavelength * Math.PI * 2) * pattern.amplitude + noiseY;
                        break;
                        
                    default:
                        x = startX;
                        y = startY;
                }
                
                points.push({ x, y });
            }
            
            // Catmull-Rom spline ile smooth yap
            return smoothPathWithSpline(points);
        }

        // ðŸŒ€ CATMULL-ROM SPLINE - Ã‡ok smooth geÃ§iÅŸler
        function smoothPathWithSpline(points) {
            if (points.length < 4) return points;
            
            const smoothPoints = [];
            const tension = 0.5; // Curve tension
            
            for (let i = 0; i < points.length - 3; i++) {
                const p0 = points[i];
                const p1 = points[i + 1];
                const p2 = points[i + 2];
                const p3 = points[i + 3];
                
                // Her segment iÃ§in interpolation
                const steps = 8;
                for (let t = 0; t < steps; t++) {
                    const tNorm = t / steps;
                    const tt = tNorm * tNorm;
                    const ttt = tt * tNorm;
                    
                    // Catmull-Rom formula
                    const q0 = -tension * ttt + 2 * tension * tt - tension * tNorm;
                    const q1 = (2 - tension) * ttt + (tension - 3) * tt + 1;
                    const q2 = (tension - 2) * ttt + (3 - 2 * tension) * tt + tension * tNorm;
                    const q3 = tension * ttt - tension * tt;
                    
                    const x = p0.x * q0 + p1.x * q1 + p2.x * q2 + p3.x * q3;
                    const y = p0.y * q0 + p1.y * q1 + p2.y * q2 + p3.y * q3;
                    
                    smoothPoints.push({ x, y });
                }
            }
            
            return smoothPoints;
        }

        window.addEventListener('DOMContentLoaded', () => {
            forceFullScreenCanvas();
        });

        document.addEventListener("CABLES.jsLoaded", function (event) {
            forceFullScreenCanvas();
            
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "js/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true }
            });
            
            hideStatsPanels();
            setTimeout(forceFullScreenCanvas, 50);
        });

        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
        
        setInterval(hideStatsPanels, 1000);
        setInterval(forceFullScreenCanvas, 2000);
        
        window.addEventListener('resize', () => {
            try {
                if (window.parent !== window) {
                    parentWidth = window.parent.innerWidth;
                    parentHeight = window.parent.innerHeight;
                }
            } catch(e) {
                parentWidth = window.innerWidth;
                parentHeight = window.innerHeight;
            }
            forceFullScreenCanvas();
        });

        window.addEventListener('message', (event) => {
            if (event.data.type === 'parentResize') {
                parentWidth = event.data.width;
                parentHeight = event.data.height;
                forceFullScreenCanvas();
            }
        });
    </script>
</body>
</html>
